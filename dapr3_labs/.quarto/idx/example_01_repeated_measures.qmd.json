{"title":"Analysis Example: Repeated-measures","markdown":{"yaml":{"title":"Analysis Example: Repeated-measures","link-citations":"yes","code-fold":true,"params":{"SHOW_SOLS":true,"TOGGLE":true}},"headingText":"Overview","containsRefs":false,"markdown":"\n\n```{r setup, include=F}\nknitr::opts_chunk$set(message = F, warning = F, fig.align = 'center')\n```\n\n:::frame\n\nEach of these pages provides an analysis run through for a different type of design. Each document is structured in the same way:  \n\n  - First the data and research context is introduced. For the purpose of these tutorials, we will only use examples where the data can be shared - either because it is from an open access publication, or because it is unpublished or simulated. \n  - Second, we go through any tidying of the data that is required, before creating some brief descriptives and visualizations of the raw data.\n  - Then, we conduct an analysis. Where possible, we translate the research questions into formal equations prior to fitting the models in **lme4**. Model comparisons are conducted, along with checks of distributional assumptions on our model residuals. \n  - Finally, we visualize and interpret our analysis.\n  \nPlease note that there will be only minimal explanation of the steps undertaken here, as these pages are intended as example analyses rather than additional labs readings. Please also be aware that there are many decisions to be made throughout conducting analyses, and it may be the case that you disagree with some of the choices we make here. As always with these things, it is how we justify our choices that is important. We warmly welcome any feedback and suggestions to improve these examples: please email [ug.ppls.stats@ed.ac.uk](mailto:ug.ppls.stats@ed.ac.uk). \n\n:::\n\n\nThe idea behind \"repeated measures\" is that the same variable is measured on the same set of subjects over two or more time periods or under different conditions.  \n\nThe data used for this worked example are simulated to represent data from 50 participants, each measured at 3 different time-points on an outcome variable of interest. This is a fairly simple design, leading from a question such as \"how does [dependent variable] change over time?\"\nYou might easily think of the 3 time points as 3 different experimental conditions instead (condition1, condition2, condition3) and ask \"how does [dv] change over depending on [independent variable]?\"\n\n\nThis is a very simple way to simulate repeated measures data structure (with long data). There are a good number of other approaches, but this will do for now as you may well be familiar with all the functions involved: \n```{r}\nset.seed(347)\nlibrary(tidyverse)\nsimRPT <- tibble(\n  pid = factor(rep(paste(\"ID\", 1:50, sep=\"\"),each=3)),\n  ppt_int = rep(rnorm(50,0,10),each=3), # add some participantz random-ness\n  dv = rnorm(150,c(40,50,70),sd=10) + ppt_int,\n  iv = factor(rep(c(\"T1\", \"T2\", \"T3\"), each=1, 50))\n)\n```\n\n:::rtip\nIf you are unclear about any section of the code above, why not try running small bits of it in your console to see what it is doing?   \nFor instance, try running:\n\n- `paste(\"ID\", 1:50, sep=\"\")`  \n- `rep(paste(\"ID\", 1:50, sep=\"\"),each=3)`  \n- `factor(rep(paste(\"ID\", 1:50, sep=\"\"),each=3))`  \n\n:::\n\n\n# Data Wrangling\n\nBecause we simulated our data, it is already nice and tidy. Each observation is a row, and we have variable indicating participant id (`pid`).  \n```{r}\nhead(simRPT)\n```\n\n# Descriptives\nLet' see our summaries per time-point:\n\n```{r}\nsumRPT <- \n  simRPT %>%\n  group_by(iv) %>%\n  summarise(\n    n = n_distinct(pid),\n    mean.dv = round(mean(dv, na.rm=T),2),\n    sd.dv = round(sd(dv, na.rm=T),2)\n    )\nsumRPT\n```\nWe can make this a little prettier:\n```{r}\nlibrary(knitr)\nlibrary(kableExtra)\nkable(sumRPT) %>%\n  kable_styling(\"striped\")\n```\n\nWell...we knew what the answer was going to be, but there we have it, our scores improve across the three administrations of our test.\n\n# Visualizations\nWe can construct some simple plots showing distribution of the outcome variable at each level of the independent variable (iv): \n\n```{r}\nsimRPT %>% \n  ggplot(aes(x = iv, y = dv)) + \n  geom_violin() + \n  geom_jitter(alpha=.5,width=.1,height=0) + \n  labs(x=\"Time\", y = \"Test Score\", \n       title=\"Scores across trials\", \n       subtitle = \"Violin Plots with (jittered) Observations\")+\n  theme_minimal()\n```\n\nSo what does this show? Essentially we are plotting all responses at each point in time. The points are `jittered` so that they are not all overlaid on one another. The areas marked at each time point are mirrored density plots (i.e. they show the distribution of the scores at each point in time). \n\nIf you want to get an intuitive sense of these plotted areas, look at them against the mean's and sd's per time point calculated above.\n\n```{r}\nsimRPT %>% \n  ggplot(aes(as.numeric(iv), dv)) +  \n  stat_summary(fun.data = mean_cl_boot, geom=\"ribbon\", alpha=.3) + \n  stat_summary(fun.y = mean, geom=\"line\") + \n  labs(x=\"Time\", y = \"Test Score\", \n       title=\"Scores across trials\", \n       subtitle = \"Mean and Boostrapped 95% Confidence Intervals\")\n```\n\nWe can also show each participants' trajectory over time, by using the `group` aesthetic mapping. \n```{r}\nsimRPT %>%\n  ggplot(aes(x = iv, y = dv)) +\n  geom_point(size=3, alpha=.4)+\n  geom_line(aes(group=pid), alpha = .2) +\n  theme_minimal()\n```\n\n\n\n# Analysis\n\n## Equations\nWe're going to fit this model, and examine the change in `dv` associated with moving from time-point 1 to each subsequent time-point.  \nRecall that because `iv` is categorical with 3 levels, we're going to be estimating 2 ($3-1$) coefficients. \n$$\n\\begin{aligned}\n  \\operatorname{dv}_{i[j]} &= \\beta_{0i} + \\beta_1(\\operatorname{iv}_{\\operatorname{T2}_j}) + \\beta_2(\\operatorname{iv}_{\\operatorname{T3}_j}) + \\varepsilon_{i[j]} \\\\\n    \\beta_{0i} &= \\gamma_{00} + \\zeta_{0i} \\\\ \n    & \\text{for }\\operatorname{pid}\\text{ i = 1,} \\dots \\text{,I}\n\\end{aligned}\n$$\n\n\n## Fitting the models\n\n\n```{r}\nlibrary(lme4)\n```\n\nHere we run an empty model so that we have something to compare our model which includes our iv. Other than to give us a reference model, we do not have a huge amount of interest in this.\n\n```{r}\nm0 <- lmer(dv ~ 1 + (1 | pid), data = simRPT)\n```\n\nNext, we specify our model. Here we include a fixed effect of our predictor (group membership, `iv`), and a random effect of participant (`iv`) to take account of the fact we have three measurements per person.\n\n```{r}\nm1 <- lmer(dv ~ 1 + iv + (1 | pid), data = simRPT)\nsummary(m1)\n```\n\nAnd we can compare our models.  \n```{r}\nlibrary(pbkrtest)\nPBmodcomp(m1, m0)\n```\n\n```{r}\nanova(m0,m1)\n```\n\nOK, so we can see that we appear to have a significant effect of our repeated factor here. Our parametric bootstrap LRT is in agreement here. \n\n:::frame\n__Comparison to `aov()`__\n\nUsing `anova()` to compare multilevel models will not give you a typical ANOVA output.  \nFor piece of mind, it can be useful to compare how we might do this in `aov()`\n\n```{r}\nm2 <- aov(dv ~ iv + Error(pid), data = simRPT)\n```\n\nHere the term `Error(pid)` is specifying the within person error, or residual. This is what we are doing with our random effect `(1 | pid)` in `lmer()`\n\nAnd we can compare the model sums of squares from both approaches to see the equivalence:\n\n```{r}\nsummary(m2)\n```\n\n```{r}\nanova(m1)\n```\n:::\n\n\n## Check model\n\nThe residuals look reasonably normally distributed, and there seems to be fairly constant variance across the linear predictor. We might be a little concerned about the potential tails of the plot below, at which residuals don't appear to have a mean of zero\n```{r}\nplot(m1, type = c(\"p\",\"smooth\"))\nlibrary(lattice)\nqqmath(m1)\n```\nRandom effects are (roughly) normally distributed:\n```{r}\nrans <- as.data.frame(ranef(m1)$pid)\nggplot(rans, aes(sample = `(Intercept)`)) + \n  stat_qq() + stat_qq_line() +\n  labs(title=\"random intercept\")\n```\n\n# Visualise Model\n\n```{r}\nlibrary(sjPlot)\nplot_model(m1, type=\"pred\")\nplot_model(m1, type=\"re\") # an alternative: dotplot.ranef.mer(ranef(m1))\n```\n\n# Interpret model\n\n__Parametric bootstrap 95% CIs:__\n\n```{r}\nconfint(m1, method = \"boot\")\n```\n\n__Case-resample bootstrap 95% CIs:__\n\n```{r}\nlibrary(lmeresampler)\nbootmodel <- bootstrap(m1, fixef, type = \"case\", B = 999, resample = c(TRUE,FALSE))\nconfint(bootmodel, type = \"perc\")\n```\n\n```{r}\nres <- confint(bootmodel, type=\"perc\")\nres <- res %>% mutate_if(is.numeric,~round(.,2))\nres\n```\n\n\nWriting up an interpretation of this is a bit clunky as we have abstract names for our variables like \"dv\" and \"iv\", but as a rough starting point: \n\n:::int\n\nChange in [dv] over [iv] was modeled using a linear mixed effects model, with a fixed effect of [iv] and a by-[pid] random intercepts. At baseline, scores on [dv] were estimated at `r res[1,2]` (cluster-resample bootstrap 95% CI: `r res[1,3]`--`r res[1,4]`). Results indicated that, relative to time-point 1, scores at time-point 2 increased by `r res[2,2]` (`r res[2,3]`--`r res[2,4]`), and at time-point 3 had increased by `r res[3,2]` (`r res[3,3]`--`r res[3,4]`). \n\n\n:::\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"include-in-header":["assets/toggling.html"],"number-sections":false,"output-file":"example_01_repeated_measures.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.38","toc_float":true,"theme":["united","assets/style-labs.scss"],"code-copy":false,"title":"Analysis Example: Repeated-measures","link-citations":"yes","params":{"SHOW_SOLS":true,"TOGGLE":true}},"extensions":{"book":{"multiFile":true}}}}}