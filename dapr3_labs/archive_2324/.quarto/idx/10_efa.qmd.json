{"title":"10. EFA 1","markdown":{"yaml":{"title":"10. EFA 1","params":{"SHOW_SOLS":true,"TOGGLE":true},"editor_options":{"chunk_output_type":"console"}},"headingText":"knitr::opts_chunk$set(cache = TRUE)","containsRefs":false,"markdown":"\n\n```{r}\n#| label: setup\n#| include: false\nsource('assets/setup.R')\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(effects)\nlibrary(knitr)\nlibrary(kableExtra)\nlibrary(xaringanExtra)\nxaringanExtra::use_panelset()\nlibrary(lavaan)\nlibrary(semPlot)\noptions(digits=3, scipen = 3)\n.pp <- function(command,top=3,bottom=-3,l=FALSE) {\n  t <- capture.output(eval(command))\n  ln <- length(t)\n  if (class(l)!='logical') {\n    i=0\n    for (n in l) {\n      if (i>0) {\n        cat(\"...\",sep=\"\\n\")\n      }\n      i=i+1\n      if (length(n)==1 && (i == 1 || i == length(l))) {\n        if (n<0) {\n          s <- n+1+ln\n          n <- c(s:ln)\n        } else {\n          n <- c(1:n)\n        }\n      }\n      if (!(0 %in% n)) {\n        cat(t[n],sep=\"\\n\")\n      }\n    }\n  } else {\n    if (top != 0) {\n      cat(t[1:top],sep=\"\\n\")\n    }\n    cat(\"...\",sep=\"\\n\")\n    if (bottom !=0) {\n      bottom <- bottom+1+ln\n      cat(t[bottom:ln],sep=\"\\n\")\n    }\n  }\n}\nqcounter <- function(){\n  if(!exists(\"qcounter_i\")){\n    qcounter_i <<- 1\n  }else{\n    qcounter_i <<- qcounter_i + 1\n  }\n  qcounter_i\n}\n```\n\n\n\n:::lo\n**Relevant packages**\n\n+ psych\n+ GPArotation\n\n::: \n\n# PCA vs FA  \n\nWhere **PCA** aims to summarise a set of measured variables into a set of orthogonal (uncorrelated) components as linear combinations (a weighted average) of the measured variables, **Factor Analysis (FA)** assumes that the relationships between a set of measured variables can be explained by a number of underlying *latent factors*.   \n  \nNote how the directions of the arrows in @fig-pcafa are different between PCA and FA - in PCA, each component $C_i$ is the weighted combination of the observed variables $y_1, ...,y_n$, whereas in FA, each measured variable $y_i$ is seen as *generated by* some latent factor(s) $F_i$ plus some unexplained variance $u_i$.   \n\nIt might help to read the $\\lambda$s as beta-weights ($b$, or $\\beta$), because that's all they really are. \nThe equation $y_i = \\lambda_{1i} F_1 + \\lambda_{2i} F_2 + u_i$ is just our way of saying that the variable $y_i$ is the manifestation of some amount ($\\lambda_{1i}$) of an underlying factor $F_1$, some amount ($\\lambda_{2i}$) of some other underlying factor $F_2$, and some error ($u_i$). \n\n```{r}\n#| label: fig-pcafa\n#| echo: false\n#| fig-cap: \"Path diagrams for PCA and FA\"\n#| out-width: \"1000px\"\nknitr::include_graphics(\"images/pcaefa/pca_efa.png\")\n```\n\nIn **_Exploratory_ Factor Analysis (EFA)**, we are starting with no hypothesis about either the number of latent factors or about the specific relationships between latent factors and measured variables (known as the *factor structure*). Typically, all variables will load on all factors, and a transformation method such as a rotation (we'll cover this in more detail below) is used to help make the results more easily interpretable.^[When we have some clear hypothesis about relationships between measured variables and latent factors, we might want to impose a specific factor structure on the data (e.g., items 1 to 10 all measure social anxiety, items 11 to 15 measure health anxiety, and so on). When we impose a specific factor structure, we are doing **Confirmatory Factor Analysis (CFA)**. This is not covered in this course, but it's important to note that in practice EFA is not wholly \"exploratory\" (your theory *will* influence the decisions you make) nor is CFA wholly \"confirmatory\" (in which you will inevitably get tempted to explore how changing your factor structure might improve fit).] \n\n\n# Suitability of items for EFA\n\nThere are various ways of assessing the suitability of our items for exploratory factor analysis, and most of them rely on examining the observed correlations between items.  \n\n:::statbox\n__Look at the correlation matrix__  \n\nUse a function such as `cor` or `corr.test(data)` (from the **psych** package) to create the correlation matrix.  \n\n:::\n\n:::statbox\n__Bartlett's Test__  \n\nThe function `cortest.bartlett(cor(data), n = nrow(data))` conducts \"Bartlett's test\". This tests against the null that the correlation matrix is proportional to the identity matrix (a matrix of all 0s except for 1s on the diagonal).  \n\n  - Null hypothesis: observed correlation matrix is equivalent to the identity matrix  \n  - Alternative hypothesis: observed correlation matrix is not equivalent to the identity matrix.  \n  \n\n\n::: {.callout-note collapse=\"true\"}\n#### What is the identity matrix?\n\nThe \"Identity matrix\" is a matrix of all 0s except for 1s on the diagonal.  \ne.g. for a 3x3 matrix:  \n$$\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1 \\\\\n\\end{bmatrix}\n$$\nIf a correlation matrix looks like this, then it means there is __no__ shared variance between the items, so it is not suitable for factor analysis\n:::\n\n:::\n\n:::statbox\n__Kaiser, Meyer, Olkin Measure of Sampling Adequacy__  \n\nYou can check the \"factorability\" of the correlation matrix using `KMO(data)` (also from **psych**!).  \n\n- Rules of thumb: \n    - $0.8 < MSA < 1$: the sampling is adequate\n    - $MSA <0.6$: sampling is not adequate \n    - $MSA \\sim 0$: large partial correlations compared to the sum of correlations. Not good for FA  \n    \n    \n::: {.callout-note collapse=\"true\"}\n#### Kaiser's suggested cuts  \n\nThese are Kaiser's corresponding adjectives suggested for each level of the KMO:  \n\n- 0.00 to 0.49 \"unacceptable\"  \n- 0.50 to 0.59 \"miserable\"  \n- 0.60 to 0.69 \"mediocre\"  \n- 0.70 to 0.79 \"middling\"  \n- 0.80 to 0.89 \"meritorious\"  \n- 0.90 to 1.00 \"marvelous\"  \n\n:::\n\n:::\n\n:::statbox\n__Check for linearity__  \n\nIt also makes sense to check for linearity of relationships prior to conducting EFA. EFA is all based on correlations, which assume the relations we are capturing are linear.  \n\nYou can check linearity of relations using `pairs.panels(data)` (also from **psych**), and you can view the histograms on the diagonals, allowing you to check univariate normality (which is usually a good enough proxy for multivariate normality). \n\n:::\n\n\n\n# Exercises: Conduct Problems  \n\n\n:::frame\n__Data: Conduct Problems__  \n\nA researcher is developing a new brief measure of Conduct Problems. She has collected data from n=450 adolescents on 10 items, which cover the following behaviours:  \n\n1. Stealing\n1. Lying\n1. Skipping school\n1. Vandalism\n1. Breaking curfew\n1. Threatening others\n1. Bullying\n1. Spreading malicious rumours\n1. Using a weapon \n1. Fighting\n\nYour task is to use the dimension reduction techniques you learned about in the lecture to help inform how to organise the items she has developed into subscales.  \n\nThe data can be found at https://uoepsy.github.io/data/conduct_probs.csv \n\n:::\n\n## 1. Check Suitability\n\n`r qbegin(qcounter())`\nRead in the dataset from [https://uoepsy.github.io/data/conduct_probs.csv](https://uoepsy.github.io/data/conduct_probs.csv).  \nThe first column is clearly an ID column, and it is easiest just to discard this when we are doing factor analysis.  \n  \nCreate a correlation matrix for *the items*.  \nInspect the items to check their suitability for exploratory factor analysis.   \n\n\n`r qend()` \n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nlibrary(psych)\ndf <- read.csv(\"https://uoepsy.github.io/data/conduct_probs.csv\")\n# discard the first column\ndf <- df[,-1]\n\ncorr.test(df)  \n\ncortest.bartlett(cor(df), n=450)\n\nKMO(df)  \n\npairs.panels(df)\n```\nor alternatively, if you want a ggplot based approach:\n```{r message=FALSE}\nlibrary(GGally)\nggpairs(data=df, diag=list(continuous=\"density\"), axisLabels=\"show\")\n```\n`r solend()`\n\n## 2. How many factors?\n\n`r qbegin(qcounter())`\nHow many dimensions should be retained? This question can be answered in the same way as we did above for PCA. \n  \nUse a scree plot, parallel analysis, and MAP test to guide you.   \nYou can use `fa.parallel(data, fa = \"fa\")` to conduct both parallel analysis and view the scree plot!   \n`r qend()` \n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nfa.parallel(df, fa = \"fa\")\n```\nIn this case the scree plot has a kink at the third factor, so we probably want to retain 2 factors.  \n  \nWe can conduct the MAP test using `VSS(data)`.\n```{r}\nVSS(df, plot = FALSE, n = ncol(df))$map\n```\nThe MAP test suggests retaining 2 factors.  \n`r solend()`\n\n## 3. Perform EFA\n\nNow we need to perform the factor analysis. But there are two further things we need to consider, and they are:  \n\na) whether we want to apply a __rotation__ to our factor loadings, in order to make them easier to interpret, and  \nb) how do we want to extract our factors (it turns out there are loads of different approaches!). \n\n\n:::statbox\n**Rotations?** \n\nRotations are so called because they transform our loadings matrix in such a way that it can make it more easy to interpret. You can think of it as a transformation applied to our loadings in order to optimise interpretability, by maximising the loading of each item onto one factor, while minimising its loadings to others. We can do this by simple rotations, but maintaining our axes (the factors) as perpendicular (i.e., uncorrelated) as in @fig-rot2, or we can allow them to be transformed beyond a rotation to allow the factors to correlate (@fig-rot3). \n```{r}\n#| label: fig-rot1\n#| fig-cap: \"No rotation\"\n#| echo: false\nknitr::include_graphics(\"images/pcaefa/rot1.png\")\n```\n\n```{r}\n#| label: fig-rot2\n#| fig-cap: \"Orthogonal rotation\"\n#| echo: false\nknitr::include_graphics(\"images/pcaefa/rot2.png\")\n```\n\n```{r}\n#| label: fig-rot3\n#| fig-cap: \"Oblique rotation\"\n#| echo: false\nknitr::include_graphics(\"images/pcaefa/rot3.png\")\n```\nIn our path diagram of the model (@fig-efarot), all the factor loadings remain present, but some of them become negligible. We can also introduce the possible correlation between our factors, as indicated by the curved arrow between $F_1$ and $F_2$. \n\n```{r}\n#| label: fig-efarot\n#| fig-cap: \"Path diagrams for EFA with rotation\"\n#| out-width: \"1000px\"\n#| echo: false\nknitr::include_graphics(\"images/pcaefa/efa_rot.png\")\n```\n\n:::\n\n:::frame\n**Factor Extraction**  \n\nPCA (using eigendecomposition) is itself a method of extracting the different dimensions from our data. However, there are lots more available for factor analysis. \n\nYou can find a lot of discussion about different methods both in the help documentation for the `fa()` function from the psych package: \n\n>Factoring method fm=\"minres\" will do a minimum residual as will fm=\"uls\". Both of these use a first derivative. fm=\"ols\" differs very slightly from \"minres\" in that it minimizes the entire residual matrix using an OLS procedure but uses the empirical first derivative. This will be slower. fm=\"wls\" will do a weighted least squares (WLS) solution, fm=\"gls\" does a generalized weighted least squares (GLS), fm=\"pa\" will do the principal factor solution, fm=\"ml\" will do a maximum likelihood factor analysis. fm=\"minchi\" will minimize the sample size weighted chi square when treating pairwise correlations with different number of subjects per pair. fm =\"minrank\" will do a minimum rank factor analysis. \"old.min\" will do minimal residual the way it was done prior to April, 2017 (see discussion below). fm=\"alpha\" will do alpha factor analysis as described in Kaiser and Coffey (1965)\n\nAnd there are lots of discussions both in papers and on [forums](https://stats.stackexchange.com/questions/50745/best-factor-extraction-methods-in-factor-analysis). \n\nAs you can see, this is a complicated issue, but when you have a large sample size, a large number of variables, for which you have similar communalities, then the extraction methods tend to agree. For now, don't fret too much about the factor extraction method.^[(It's a *bit* like the optimiser issue in the multi-level model block)]\n\n:::\n\n\n`r qbegin(qcounter())`\nUse the function `fa()` from the **psych** package to conduct and EFA to extract 2 factors (this is what *we* suggest based on the various tests above, but *you* might feel differently - the ideal number of factors is subjective!). Use a suitable rotation (`rotate = ?`) and extraction method (`fm = ?`).  \n```{r}\n#| eval: false\nconduct_efa <- fa(data, nfactors = ?, rotate = ?, fm = ?)\n```\n\n`r qend()` \n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nFor example, you could choose an oblimin rotation to allow factors to correlate and use minres as the extraction method.  \n```{r}\nconduct_efa <- fa(df, nfactors=2, rotate='oblimin', fm=\"minres\")\n```\n`r solend()`\n\n## 4. Inspect\n\nWe can simply print the name of our model in order to see a lot of information. Let's go through it in pieces.   \n\n:::statbox\n\n__Loadings__  \n```{r}\n#| echo: false\n.pp(conduct_efa, l=list(1:15))\n```\n\nFactor loading's, like PCA loading's, show the relationship of each measured variable to each factor. They range between -1.00 and 1.00\nLarger absolute values represent stronger relationship between measured variable and factor.  \n\n- The columns that (depending upon estimation method) might be called `MR`/`ML`/`PC` are the factors. The number assigned to is arbitrary, and they might not always be in a numeric order (this has to do with a rotated solution). Typically, the numbering maps to how much variance each factor account for. \n- __h2:__ This is the \"communality\", which is how much variance in the item is explained by the factors. It is calculated as the sum of the squared loadings.  \n- __u2:__ This is $1 - h2$. It is the residual variance, or the \"uniqueness\" for that item (i.e. the amount left unexplained).  \n- __com:__ This is the \"Item complexity\". It tells us how much a given item reflects a single factor (vs being \"more complex\" in that it represents multiple factors). It equals one if an item loads only on one factor, 2 if evenly loads on two factors, etc.  \n\nYou can get these on their own using\n```{r}\n#| eval: false\nconduct_efa$loadings\n```\n\n:::\n\n:::statbox\n__Variance Accounted For__  \n```{r}\n#| echo: false\n.pp(conduct_efa, l=list(16:21))\n```\n\nBelow the factor loadings, we have a familiar set of measures of the variance in the data accounted for by each factor. This is very similar to what we saw with PCA.  \n\n- SS loadings: The sum of the squared loadings. The eigenvalues.  \n- Proportion Var: how much of the overall variance the factor accounts for out of all the variables. \n- Cumulative Var: cumulative sum of Proportion Var.\n- Proportion Explained: relative amount of variance explained ($\\frac{\\text{Proportion Var}}{\\text{sum(Proportion Var)}}$.\n- Cumulative Proportion: cumulative sum of Proportion Explained.\n\nYou can get these on their own using\n```{r}\n#| eval: false\nconduct_efa$Vaccounted\n```\n\n:::\n\n:::statbox\n__Factor Correlations__  \n```{r}\n#| echo: false\n.pp(conduct_efa, l=list(22:28))\n```\n\nWhether we see this section will depend if we have run a factor analysis with $\\geq 2$ factors and a rotation.  \n\n- `factor correlations`: shows the correlation matrix between the factors. \n- `mean item complexity`: shows the mean of the `com` column from the loadings above.  \n\nYou can get these on their own using\n```{r}\n#| eval: false\nconduct_efa$Phi\n```\n\n:::\n\n\n:::statbox\n__Tests, Fit Indices etc__  \n\nWe also get a whole load of other stuff that can sometimes be useful. These include: a test of an hypothesis that the 2 factors are sufficient; information on the number of observations; fit indices such as RMSEA, TLI RMSR etc; and measures of factor score adequacy (we'll get to talking about factor scores next week).\n```{r}\n#| echo: false\n.pp(conduct_efa, l=list(29:48))\n```\n\n\n\n:::\n\n`r qbegin(qcounter())`\nInspect the loadings (`conduct_efa$loadings`) and give the factors you extracted labels based on the patterns of loadings.  \n  \nLook back to the description of the items, and suggest a name for your factors  \n`r qend()` \n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nYou can inspect the loadings using:\n```{r}\nprint(conduct_efa$loadings, sort=TRUE)\n```\nWe can see that the first five items have high loadings for one factor and the second five items have high loadings for the other.  \n  \nThe first five items all have in common that they are non-aggressive forms of conduct problems, while the last five items are all aggressive behaviours. We could, therefore, label our factors: ‘non-aggressive’ and ‘aggressive’ conduct problems.\n`r solend()`\n\n`r qbegin(qcounter())`\nHow correlated are your factors?  \n\nWe can inspect the factor correlations (if we used an oblique rotation) using:\n```{r}\n#| eval: false\nconduct_efa$Phi\n```\n`r qend()` \n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nconduct_efa$Phi\n```\nWe can see here that there is a moderate correlation between the two factors. An oblique rotation would be appropriate here. \n`r solend()`\n\n## 5. Write-up \n\n`r qbegin(qcounter())`\nDrawing on your previous answers and conducting any additional analyses you believe would be necessary to identify an optimal factor structure for the 10 conduct problems, write a brief text that summarises your method and the results from your chosen optimal model.\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nThe main principles governing the reporting of statistical results are transparency and reproducibility (i.e., someone should be able to reproduce your analysis based on your description).\n\nAn example summary would be:\n\n:::int \n\nFirst, the data were checked for their suitability for factor analysis. Normality was checked using visual inspection of histograms, linearity was checked through the inspection of the linear and lowess lines for the pairwise relations of the variables, and factorability was confirmed using a KMO test, which yielded an overall KMO of $.87$ with no variable KMOs $<.50$. \nAn exploratory factor analysis was conducted to inform the structure of a new conduct problems test. Inspection of a scree plot alongside parallel analysis (using principal components analysis; PA-PCA) and the MAP test were used to guide the number of factors to retain. All three methods suggested retaining two factors; however, a one-factor and three-factor solution were inspected to confirm that the two-factor solution was optimal from a substantive and practical perspective, e.g., that it neither blurred important factor distinctions nor included a minor factor that would be better combined with the other in a one-factor solution. These factor analyses were conducted using minres extraction and (for the two- and three-factor solutions) an oblimin rotation, because it was expected that the factors would correlate. Inspection of the factor loadings and correlations reinforced that the two-factor solution was optimal: both factors were well-determined, including 5 loadings $>|0.3|$ and the one-factor model blurred the distinction between different forms of conduct problems. \nThe factor loadings are provided in @tbl-loadingtab^[You should provide the table of factor loadings. It is conventional to omit factor loadings $<|0.3|$; however, be sure to ensure that you mention this in a table note.]. Based on the pattern of factor loadings, the two factors were labelled 'aggressive conduct problems' and 'non-aggressive conduct problems'. These factors had a  correlation of $r=.43$. Overall, they accounted for 57% of the variance in the items, suggesting that a two-factor solution effectively summarised the variation in the items.\n\n\n```{r}\n#| label: tbl-loadingtab\n#| echo: false\n#| tbl-cap: \"Factor Loadings\"\n\n\nloadings = unclass(conduct_efa$loadings)\nloadings = round(loadings, 3)\nloadings[abs(loadings) < 0.3] = NA\noptions(knitr.kable.NA = '')\nknitr::kable(loadings, digits = 2)\n```\n\n:::\n\n\n`r solend()`\n\n# PCA & EFA Comparison Exercise\n\n`r qbegin(qcounter())`\nUsing the same data, conduct a PCA using the `principal()` function.  \n  \nWhat differences do you notice compared to your EFA?  \n  \nDo you think a PCA or an EFA is more appropriate in this particular case?\n`r qend()` \n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nWe can use:\n```{r}\nprincipal(df, nfactors=2)\n```\nWe can see that while the loadings differ somewhat between the EFA and the PCA, the overall pattern is quite similar. This is not always the case, especially when the item communalities are low.  \n  \nIn terms of which method is more appropriate, arguably EFA would be more appropriate in this case because our researcher wishes to measure a theoretical construct (conduct problems), rather than simply reduce the dimensions of her data.\n`r solend()`\n\n\n\n<div class=\"tocify-extend-page\" data-unique=\"tocify-extend-page\" style=\"height: 0;\"></div>","srcMarkdownNoYaml":"\n\n```{r}\n#| label: setup\n#| include: false\nsource('assets/setup.R')\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(effects)\nlibrary(knitr)\nlibrary(kableExtra)\nlibrary(xaringanExtra)\nxaringanExtra::use_panelset()\nlibrary(lavaan)\nlibrary(semPlot)\n# knitr::opts_chunk$set(cache = TRUE)\noptions(digits=3, scipen = 3)\n.pp <- function(command,top=3,bottom=-3,l=FALSE) {\n  t <- capture.output(eval(command))\n  ln <- length(t)\n  if (class(l)!='logical') {\n    i=0\n    for (n in l) {\n      if (i>0) {\n        cat(\"...\",sep=\"\\n\")\n      }\n      i=i+1\n      if (length(n)==1 && (i == 1 || i == length(l))) {\n        if (n<0) {\n          s <- n+1+ln\n          n <- c(s:ln)\n        } else {\n          n <- c(1:n)\n        }\n      }\n      if (!(0 %in% n)) {\n        cat(t[n],sep=\"\\n\")\n      }\n    }\n  } else {\n    if (top != 0) {\n      cat(t[1:top],sep=\"\\n\")\n    }\n    cat(\"...\",sep=\"\\n\")\n    if (bottom !=0) {\n      bottom <- bottom+1+ln\n      cat(t[bottom:ln],sep=\"\\n\")\n    }\n  }\n}\nqcounter <- function(){\n  if(!exists(\"qcounter_i\")){\n    qcounter_i <<- 1\n  }else{\n    qcounter_i <<- qcounter_i + 1\n  }\n  qcounter_i\n}\n```\n\n\n\n:::lo\n**Relevant packages**\n\n+ psych\n+ GPArotation\n\n::: \n\n# PCA vs FA  \n\nWhere **PCA** aims to summarise a set of measured variables into a set of orthogonal (uncorrelated) components as linear combinations (a weighted average) of the measured variables, **Factor Analysis (FA)** assumes that the relationships between a set of measured variables can be explained by a number of underlying *latent factors*.   \n  \nNote how the directions of the arrows in @fig-pcafa are different between PCA and FA - in PCA, each component $C_i$ is the weighted combination of the observed variables $y_1, ...,y_n$, whereas in FA, each measured variable $y_i$ is seen as *generated by* some latent factor(s) $F_i$ plus some unexplained variance $u_i$.   \n\nIt might help to read the $\\lambda$s as beta-weights ($b$, or $\\beta$), because that's all they really are. \nThe equation $y_i = \\lambda_{1i} F_1 + \\lambda_{2i} F_2 + u_i$ is just our way of saying that the variable $y_i$ is the manifestation of some amount ($\\lambda_{1i}$) of an underlying factor $F_1$, some amount ($\\lambda_{2i}$) of some other underlying factor $F_2$, and some error ($u_i$). \n\n```{r}\n#| label: fig-pcafa\n#| echo: false\n#| fig-cap: \"Path diagrams for PCA and FA\"\n#| out-width: \"1000px\"\nknitr::include_graphics(\"images/pcaefa/pca_efa.png\")\n```\n\nIn **_Exploratory_ Factor Analysis (EFA)**, we are starting with no hypothesis about either the number of latent factors or about the specific relationships between latent factors and measured variables (known as the *factor structure*). Typically, all variables will load on all factors, and a transformation method such as a rotation (we'll cover this in more detail below) is used to help make the results more easily interpretable.^[When we have some clear hypothesis about relationships between measured variables and latent factors, we might want to impose a specific factor structure on the data (e.g., items 1 to 10 all measure social anxiety, items 11 to 15 measure health anxiety, and so on). When we impose a specific factor structure, we are doing **Confirmatory Factor Analysis (CFA)**. This is not covered in this course, but it's important to note that in practice EFA is not wholly \"exploratory\" (your theory *will* influence the decisions you make) nor is CFA wholly \"confirmatory\" (in which you will inevitably get tempted to explore how changing your factor structure might improve fit).] \n\n\n# Suitability of items for EFA\n\nThere are various ways of assessing the suitability of our items for exploratory factor analysis, and most of them rely on examining the observed correlations between items.  \n\n:::statbox\n__Look at the correlation matrix__  \n\nUse a function such as `cor` or `corr.test(data)` (from the **psych** package) to create the correlation matrix.  \n\n:::\n\n:::statbox\n__Bartlett's Test__  \n\nThe function `cortest.bartlett(cor(data), n = nrow(data))` conducts \"Bartlett's test\". This tests against the null that the correlation matrix is proportional to the identity matrix (a matrix of all 0s except for 1s on the diagonal).  \n\n  - Null hypothesis: observed correlation matrix is equivalent to the identity matrix  \n  - Alternative hypothesis: observed correlation matrix is not equivalent to the identity matrix.  \n  \n\n\n::: {.callout-note collapse=\"true\"}\n#### What is the identity matrix?\n\nThe \"Identity matrix\" is a matrix of all 0s except for 1s on the diagonal.  \ne.g. for a 3x3 matrix:  \n$$\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1 \\\\\n\\end{bmatrix}\n$$\nIf a correlation matrix looks like this, then it means there is __no__ shared variance between the items, so it is not suitable for factor analysis\n:::\n\n:::\n\n:::statbox\n__Kaiser, Meyer, Olkin Measure of Sampling Adequacy__  \n\nYou can check the \"factorability\" of the correlation matrix using `KMO(data)` (also from **psych**!).  \n\n- Rules of thumb: \n    - $0.8 < MSA < 1$: the sampling is adequate\n    - $MSA <0.6$: sampling is not adequate \n    - $MSA \\sim 0$: large partial correlations compared to the sum of correlations. Not good for FA  \n    \n    \n::: {.callout-note collapse=\"true\"}\n#### Kaiser's suggested cuts  \n\nThese are Kaiser's corresponding adjectives suggested for each level of the KMO:  \n\n- 0.00 to 0.49 \"unacceptable\"  \n- 0.50 to 0.59 \"miserable\"  \n- 0.60 to 0.69 \"mediocre\"  \n- 0.70 to 0.79 \"middling\"  \n- 0.80 to 0.89 \"meritorious\"  \n- 0.90 to 1.00 \"marvelous\"  \n\n:::\n\n:::\n\n:::statbox\n__Check for linearity__  \n\nIt also makes sense to check for linearity of relationships prior to conducting EFA. EFA is all based on correlations, which assume the relations we are capturing are linear.  \n\nYou can check linearity of relations using `pairs.panels(data)` (also from **psych**), and you can view the histograms on the diagonals, allowing you to check univariate normality (which is usually a good enough proxy for multivariate normality). \n\n:::\n\n\n\n# Exercises: Conduct Problems  \n\n\n:::frame\n__Data: Conduct Problems__  \n\nA researcher is developing a new brief measure of Conduct Problems. She has collected data from n=450 adolescents on 10 items, which cover the following behaviours:  \n\n1. Stealing\n1. Lying\n1. Skipping school\n1. Vandalism\n1. Breaking curfew\n1. Threatening others\n1. Bullying\n1. Spreading malicious rumours\n1. Using a weapon \n1. Fighting\n\nYour task is to use the dimension reduction techniques you learned about in the lecture to help inform how to organise the items she has developed into subscales.  \n\nThe data can be found at https://uoepsy.github.io/data/conduct_probs.csv \n\n:::\n\n## 1. Check Suitability\n\n`r qbegin(qcounter())`\nRead in the dataset from [https://uoepsy.github.io/data/conduct_probs.csv](https://uoepsy.github.io/data/conduct_probs.csv).  \nThe first column is clearly an ID column, and it is easiest just to discard this when we are doing factor analysis.  \n  \nCreate a correlation matrix for *the items*.  \nInspect the items to check their suitability for exploratory factor analysis.   \n\n\n`r qend()` \n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nlibrary(psych)\ndf <- read.csv(\"https://uoepsy.github.io/data/conduct_probs.csv\")\n# discard the first column\ndf <- df[,-1]\n\ncorr.test(df)  \n\ncortest.bartlett(cor(df), n=450)\n\nKMO(df)  \n\npairs.panels(df)\n```\nor alternatively, if you want a ggplot based approach:\n```{r message=FALSE}\nlibrary(GGally)\nggpairs(data=df, diag=list(continuous=\"density\"), axisLabels=\"show\")\n```\n`r solend()`\n\n## 2. How many factors?\n\n`r qbegin(qcounter())`\nHow many dimensions should be retained? This question can be answered in the same way as we did above for PCA. \n  \nUse a scree plot, parallel analysis, and MAP test to guide you.   \nYou can use `fa.parallel(data, fa = \"fa\")` to conduct both parallel analysis and view the scree plot!   \n`r qend()` \n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nfa.parallel(df, fa = \"fa\")\n```\nIn this case the scree plot has a kink at the third factor, so we probably want to retain 2 factors.  \n  \nWe can conduct the MAP test using `VSS(data)`.\n```{r}\nVSS(df, plot = FALSE, n = ncol(df))$map\n```\nThe MAP test suggests retaining 2 factors.  \n`r solend()`\n\n## 3. Perform EFA\n\nNow we need to perform the factor analysis. But there are two further things we need to consider, and they are:  \n\na) whether we want to apply a __rotation__ to our factor loadings, in order to make them easier to interpret, and  \nb) how do we want to extract our factors (it turns out there are loads of different approaches!). \n\n\n:::statbox\n**Rotations?** \n\nRotations are so called because they transform our loadings matrix in such a way that it can make it more easy to interpret. You can think of it as a transformation applied to our loadings in order to optimise interpretability, by maximising the loading of each item onto one factor, while minimising its loadings to others. We can do this by simple rotations, but maintaining our axes (the factors) as perpendicular (i.e., uncorrelated) as in @fig-rot2, or we can allow them to be transformed beyond a rotation to allow the factors to correlate (@fig-rot3). \n```{r}\n#| label: fig-rot1\n#| fig-cap: \"No rotation\"\n#| echo: false\nknitr::include_graphics(\"images/pcaefa/rot1.png\")\n```\n\n```{r}\n#| label: fig-rot2\n#| fig-cap: \"Orthogonal rotation\"\n#| echo: false\nknitr::include_graphics(\"images/pcaefa/rot2.png\")\n```\n\n```{r}\n#| label: fig-rot3\n#| fig-cap: \"Oblique rotation\"\n#| echo: false\nknitr::include_graphics(\"images/pcaefa/rot3.png\")\n```\nIn our path diagram of the model (@fig-efarot), all the factor loadings remain present, but some of them become negligible. We can also introduce the possible correlation between our factors, as indicated by the curved arrow between $F_1$ and $F_2$. \n\n```{r}\n#| label: fig-efarot\n#| fig-cap: \"Path diagrams for EFA with rotation\"\n#| out-width: \"1000px\"\n#| echo: false\nknitr::include_graphics(\"images/pcaefa/efa_rot.png\")\n```\n\n:::\n\n:::frame\n**Factor Extraction**  \n\nPCA (using eigendecomposition) is itself a method of extracting the different dimensions from our data. However, there are lots more available for factor analysis. \n\nYou can find a lot of discussion about different methods both in the help documentation for the `fa()` function from the psych package: \n\n>Factoring method fm=\"minres\" will do a minimum residual as will fm=\"uls\". Both of these use a first derivative. fm=\"ols\" differs very slightly from \"minres\" in that it minimizes the entire residual matrix using an OLS procedure but uses the empirical first derivative. This will be slower. fm=\"wls\" will do a weighted least squares (WLS) solution, fm=\"gls\" does a generalized weighted least squares (GLS), fm=\"pa\" will do the principal factor solution, fm=\"ml\" will do a maximum likelihood factor analysis. fm=\"minchi\" will minimize the sample size weighted chi square when treating pairwise correlations with different number of subjects per pair. fm =\"minrank\" will do a minimum rank factor analysis. \"old.min\" will do minimal residual the way it was done prior to April, 2017 (see discussion below). fm=\"alpha\" will do alpha factor analysis as described in Kaiser and Coffey (1965)\n\nAnd there are lots of discussions both in papers and on [forums](https://stats.stackexchange.com/questions/50745/best-factor-extraction-methods-in-factor-analysis). \n\nAs you can see, this is a complicated issue, but when you have a large sample size, a large number of variables, for which you have similar communalities, then the extraction methods tend to agree. For now, don't fret too much about the factor extraction method.^[(It's a *bit* like the optimiser issue in the multi-level model block)]\n\n:::\n\n\n`r qbegin(qcounter())`\nUse the function `fa()` from the **psych** package to conduct and EFA to extract 2 factors (this is what *we* suggest based on the various tests above, but *you* might feel differently - the ideal number of factors is subjective!). Use a suitable rotation (`rotate = ?`) and extraction method (`fm = ?`).  \n```{r}\n#| eval: false\nconduct_efa <- fa(data, nfactors = ?, rotate = ?, fm = ?)\n```\n\n`r qend()` \n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nFor example, you could choose an oblimin rotation to allow factors to correlate and use minres as the extraction method.  \n```{r}\nconduct_efa <- fa(df, nfactors=2, rotate='oblimin', fm=\"minres\")\n```\n`r solend()`\n\n## 4. Inspect\n\nWe can simply print the name of our model in order to see a lot of information. Let's go through it in pieces.   \n\n:::statbox\n\n__Loadings__  \n```{r}\n#| echo: false\n.pp(conduct_efa, l=list(1:15))\n```\n\nFactor loading's, like PCA loading's, show the relationship of each measured variable to each factor. They range between -1.00 and 1.00\nLarger absolute values represent stronger relationship between measured variable and factor.  \n\n- The columns that (depending upon estimation method) might be called `MR`/`ML`/`PC` are the factors. The number assigned to is arbitrary, and they might not always be in a numeric order (this has to do with a rotated solution). Typically, the numbering maps to how much variance each factor account for. \n- __h2:__ This is the \"communality\", which is how much variance in the item is explained by the factors. It is calculated as the sum of the squared loadings.  \n- __u2:__ This is $1 - h2$. It is the residual variance, or the \"uniqueness\" for that item (i.e. the amount left unexplained).  \n- __com:__ This is the \"Item complexity\". It tells us how much a given item reflects a single factor (vs being \"more complex\" in that it represents multiple factors). It equals one if an item loads only on one factor, 2 if evenly loads on two factors, etc.  \n\nYou can get these on their own using\n```{r}\n#| eval: false\nconduct_efa$loadings\n```\n\n:::\n\n:::statbox\n__Variance Accounted For__  \n```{r}\n#| echo: false\n.pp(conduct_efa, l=list(16:21))\n```\n\nBelow the factor loadings, we have a familiar set of measures of the variance in the data accounted for by each factor. This is very similar to what we saw with PCA.  \n\n- SS loadings: The sum of the squared loadings. The eigenvalues.  \n- Proportion Var: how much of the overall variance the factor accounts for out of all the variables. \n- Cumulative Var: cumulative sum of Proportion Var.\n- Proportion Explained: relative amount of variance explained ($\\frac{\\text{Proportion Var}}{\\text{sum(Proportion Var)}}$.\n- Cumulative Proportion: cumulative sum of Proportion Explained.\n\nYou can get these on their own using\n```{r}\n#| eval: false\nconduct_efa$Vaccounted\n```\n\n:::\n\n:::statbox\n__Factor Correlations__  \n```{r}\n#| echo: false\n.pp(conduct_efa, l=list(22:28))\n```\n\nWhether we see this section will depend if we have run a factor analysis with $\\geq 2$ factors and a rotation.  \n\n- `factor correlations`: shows the correlation matrix between the factors. \n- `mean item complexity`: shows the mean of the `com` column from the loadings above.  \n\nYou can get these on their own using\n```{r}\n#| eval: false\nconduct_efa$Phi\n```\n\n:::\n\n\n:::statbox\n__Tests, Fit Indices etc__  \n\nWe also get a whole load of other stuff that can sometimes be useful. These include: a test of an hypothesis that the 2 factors are sufficient; information on the number of observations; fit indices such as RMSEA, TLI RMSR etc; and measures of factor score adequacy (we'll get to talking about factor scores next week).\n```{r}\n#| echo: false\n.pp(conduct_efa, l=list(29:48))\n```\n\n\n\n:::\n\n`r qbegin(qcounter())`\nInspect the loadings (`conduct_efa$loadings`) and give the factors you extracted labels based on the patterns of loadings.  \n  \nLook back to the description of the items, and suggest a name for your factors  \n`r qend()` \n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nYou can inspect the loadings using:\n```{r}\nprint(conduct_efa$loadings, sort=TRUE)\n```\nWe can see that the first five items have high loadings for one factor and the second five items have high loadings for the other.  \n  \nThe first five items all have in common that they are non-aggressive forms of conduct problems, while the last five items are all aggressive behaviours. We could, therefore, label our factors: ‘non-aggressive’ and ‘aggressive’ conduct problems.\n`r solend()`\n\n`r qbegin(qcounter())`\nHow correlated are your factors?  \n\nWe can inspect the factor correlations (if we used an oblique rotation) using:\n```{r}\n#| eval: false\nconduct_efa$Phi\n```\n`r qend()` \n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nconduct_efa$Phi\n```\nWe can see here that there is a moderate correlation between the two factors. An oblique rotation would be appropriate here. \n`r solend()`\n\n## 5. Write-up \n\n`r qbegin(qcounter())`\nDrawing on your previous answers and conducting any additional analyses you believe would be necessary to identify an optimal factor structure for the 10 conduct problems, write a brief text that summarises your method and the results from your chosen optimal model.\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nThe main principles governing the reporting of statistical results are transparency and reproducibility (i.e., someone should be able to reproduce your analysis based on your description).\n\nAn example summary would be:\n\n:::int \n\nFirst, the data were checked for their suitability for factor analysis. Normality was checked using visual inspection of histograms, linearity was checked through the inspection of the linear and lowess lines for the pairwise relations of the variables, and factorability was confirmed using a KMO test, which yielded an overall KMO of $.87$ with no variable KMOs $<.50$. \nAn exploratory factor analysis was conducted to inform the structure of a new conduct problems test. Inspection of a scree plot alongside parallel analysis (using principal components analysis; PA-PCA) and the MAP test were used to guide the number of factors to retain. All three methods suggested retaining two factors; however, a one-factor and three-factor solution were inspected to confirm that the two-factor solution was optimal from a substantive and practical perspective, e.g., that it neither blurred important factor distinctions nor included a minor factor that would be better combined with the other in a one-factor solution. These factor analyses were conducted using minres extraction and (for the two- and three-factor solutions) an oblimin rotation, because it was expected that the factors would correlate. Inspection of the factor loadings and correlations reinforced that the two-factor solution was optimal: both factors were well-determined, including 5 loadings $>|0.3|$ and the one-factor model blurred the distinction between different forms of conduct problems. \nThe factor loadings are provided in @tbl-loadingtab^[You should provide the table of factor loadings. It is conventional to omit factor loadings $<|0.3|$; however, be sure to ensure that you mention this in a table note.]. Based on the pattern of factor loadings, the two factors were labelled 'aggressive conduct problems' and 'non-aggressive conduct problems'. These factors had a  correlation of $r=.43$. Overall, they accounted for 57% of the variance in the items, suggesting that a two-factor solution effectively summarised the variation in the items.\n\n\n```{r}\n#| label: tbl-loadingtab\n#| echo: false\n#| tbl-cap: \"Factor Loadings\"\n\n\nloadings = unclass(conduct_efa$loadings)\nloadings = round(loadings, 3)\nloadings[abs(loadings) < 0.3] = NA\noptions(knitr.kable.NA = '')\nknitr::kable(loadings, digits = 2)\n```\n\n:::\n\n\n`r solend()`\n\n# PCA & EFA Comparison Exercise\n\n`r qbegin(qcounter())`\nUsing the same data, conduct a PCA using the `principal()` function.  \n  \nWhat differences do you notice compared to your EFA?  \n  \nDo you think a PCA or an EFA is more appropriate in this particular case?\n`r qend()` \n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nWe can use:\n```{r}\nprincipal(df, nfactors=2)\n```\nWe can see that while the loadings differ somewhat between the EFA and the PCA, the overall pattern is quite similar. This is not always the case, especially when the item communalities are low.  \n  \nIn terms of which method is more appropriate, arguably EFA would be more appropriate in this case because our researcher wishes to measure a theoretical construct (conduct problems), rather than simply reduce the dimensions of her data.\n`r solend()`\n\n\n\n<div class=\"tocify-extend-page\" data-unique=\"tocify-extend-page\" style=\"height: 0;\"></div>"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"include-in-header":["assets/toggling.html"],"number-sections":false,"output-file":"10_efa.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","toc_float":true,"theme":["united","assets/style-labs.scss"],"link-citations":true,"code-copy":false,"title":"10. EFA 1","params":{"SHOW_SOLS":true,"TOGGLE":true},"editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}