---
title: "Multilevel/Mixed effects Models"
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| include: false

library(tidyverse)
library(patchwork)
source('_theme/theme_quarto.R')
```


## Terminology

```{r}
#| eval: false
tribble(
  ~word, ~freq,
  "multi-level model", 154000 + 31300,
  "hierarchical linear model", 24000,
  "mixed-effect model", 56500 + 191000,
  "mixed model", 1500000,
  "random coefficient model", 11200+6920,
  "random-effect model", 101000 + 501000,
  "random parameter model", 2140 + 1460,
  "random-intercept model", 17100 + 2930, 
  "variance components model", 6210 + 5560,
  "partial pooling", 5120,
  "mixed error-component model", 62,
  "random slope model", 4010 + 1620,
  "panel data model", 55400,
  "latent curve model", 1520,
  "growth curve model", 18400
) -> mlmname


#mlmname$freq[mlmname$freq > 100000] <- c(75000,85000, 110000,80000,95000)*1.5

#wordcloud2(mlmname, shape="diamond", size=.4)
library(wordcloud)
wordcloud(words = mlmname$word, freq = mlmname$freq, random.order=FALSE,
          min.freq=1,
          scale=c(4,.5),rot.per=0,
          fixed.asp=T,
          #ordered.colors=T,
          colors="#88B04B")
```

```{r}
#| echo: false
#| fig-cap: "(size weighted by hits on google scholar)"
#| fig-asp: .9
#| label: wordcloud
knitr::include_graphics("img_sandbox/mlmname.png")
```

## single level regression


::::{.columns}
:::{.column width="50%"}
::: {style="width:0; float:left;"}
$$
\begin{align}
& \text{for observation }j \\
\quad \\
& \text{    } \\
& \color{red}{y_j} = \color{blue}{b_0 \cdot{} 1 \; + \; b_1 \cdot{} x_{j} } + \varepsilon_j \\
\end{align}
$$
:::
:::

:::{.column width="50%" style="font-size: 70%;color:#999999"}
<br>
for observation $j$,  
<br><br>
their value of $\color{red}{y}$ =  
&nbsp;&nbsp;some number ($\color{blue}{b_0}$) +  
&nbsp;&nbsp;some amount ($\color{blue}{b_1}$) times their value of $x$ +  
&nbsp;&nbsp;their residual $\varepsilon_j$  

:::
::::

## multi-level regression

::::{.columns}
:::{.column width="50%"}
::: {style="width:0; float:left;"}
$$
\begin{align}
& \text{for observation }j\text{ in group }i \\
\quad \\
& \text{Level 1:} \\
& \color{red}{y_{ij}} = \color{blue}{b_{0i} \cdot 1 + b_{1} \cdot x_{ij}} + \varepsilon_{ij} \\
\end{align}
$$
:::
:::

:::{.column width="50%" style="font-size: 70%;color:#999999"}
<br>
for observation $j$ **from group $i$**,  
<br><br>
their value of $\color{red}{y}$ =   
&nbsp;&nbsp;some number **for group $i$** ($\color{blue}{b_{0i}}$) +  
&nbsp;&nbsp;some amount ($\color{blue}{b_1}$) times their value of $x$ +  
&nbsp;&nbsp;their residual $\varepsilon_{ij}$  
  
:::
::::

## multi-level regression

::::{.columns}
:::{.column width="50%"}
::: {style="width:0; float:left;"}
$$
\begin{align}
& \text{for observation }j\text{ in group }i \\
\quad \\
& \text{Level 1:} \\
& \color{red}{y_{ij}} = \color{blue}{b_{0i} \cdot 1 + b_{1} \cdot x_{ij}} + \varepsilon_{ij} \\
& \quad \\
& \text{Level 2:} \\
& \color{blue}{b_{0i}} = \gamma_{00} + \color{orange}{\zeta_{0i}} \\
\quad \\
\end{align}
$$
:::
:::

:::{.column width="50%" style="font-size: 70%;color:#999999"}
<br>
for observation $j$ **from group $i$**,  
<br><br>
their value of $\color{red}{y}$ =   
&nbsp;&nbsp;some number **for group $i$** ($\color{blue}{b_{0i}}$) +  
&nbsp;&nbsp;some amount ($\color{blue}{b_1}$) times their value of $x$ +  
&nbsp;&nbsp;their residual $\varepsilon_{ij}$  
<br>
group $i$'s intercept ($\color{blue}{b_{0i}}$) =  
&nbsp;&nbsp;the intercept for the average of the population of groups ($\gamma_{00}$)  
&nbsp;&nbsp;the deviation of group $i$ ($\color{orange}{\zeta_{0i}}$) from $\gamma_{00}$  

:::
::::


## multi-level regression {visibility="uncounted"}

::::{.columns}
:::{.column width="50%"}
::: {style="width:0; float:left;"}
$$
\begin{align}
& \text{for observation }j\text{ in group }i \\
\quad \\
& \text{Level 1:} \\
& \color{red}{y_{ij}} = \color{blue}{b_{0i} \cdot 1 + b_{1} \cdot x_{ij}} + \varepsilon_{ij} \\
& \quad \\
& \text{Level 2:} \\
& \color{blue}{b_{0i}} = \gamma_{00} + \color{orange}{\zeta_{0i}} \\
\quad \\
& \color{orange}{\zeta_{0i}} \sim N(0, \sigma_0) \\
& \varepsilon_{ij} \sim N(0, \sigma_\varepsilon) \\ 
\end{align}
$$
:::
:::

:::{.column width="50%" style="font-size: 70%;color:#999999"}
<br>
for observation $j$ **from group $i$**,  
<br><br>
their value of $\color{red}{y}$ =   
&nbsp;&nbsp;some number **for group $i$** ($\color{blue}{b_{0i}}$) +  
&nbsp;&nbsp;some amount ($\color{blue}{b_1}$) times their value of $x$ +  
&nbsp;&nbsp;their residual $\varepsilon_{ij}$  
<br>
group $i$'s intercept ($\color{blue}{b_{0i}}$) =  
&nbsp;&nbsp;the intercept for the average of the population of groups ($\gamma_{00}$)  
&nbsp;&nbsp;the deviation of group $i$ ($\color{orange}{\zeta_{0i}}$) from $\gamma_{00}$  
<br><br>
We are now assuming $\color{orange}{\zeta_0}$ and $\varepsilon$ to be normally distributed with a mean of 0, and we denote their variances as $\sigma_{\color{orange}{0}}^2$ and $\sigma_\varepsilon^2$ respectively.  
  
:::
::::

## multi-level (mixed-effects) regression

Sometimes, you will see the levels collapsed into one equation, as it might make for more intuitive reading:


::::{.columns}
:::{.column width="60%" style="float:left;"}

$$
\begin{align}
& \color{red}{y_{ij}} = \overbrace{(\gamma_{00} + \color{orange}{\zeta_{0i}})}^{\color{blue}{b_{0i}}} \cdot 1 + \color{blue}{b_{1} \cdot x_{ij}}  +  \varepsilon_{ij} \\
& \quad \\
& \color{orange}{\zeta_{0i}} \sim N(0, \sigma_0) \\
& \varepsilon_{ij} \sim N(0, \sigma_\varepsilon) \\ 
\end{align}
$$

:::
:::{.column width="40%" style="font-size: 70%;color:#999999"}
<br><br>
The intercept $\color{blue}{b_{0i}}$ is a "mix" of two things: 

- the fixed number $\gamma_{00}$
- group deviations $\color{orange}{\zeta_{0i}}$

:::
::::

:::aside
**other notation to be aware of**  

- Many people use the symbol $u$ as the random part - i.e. in place of $\zeta$  

- Sometimes people use $b_{00}$ as the fixed part - i.e. instead of $\gamma_{00}$  

- In various resources, you are likely to see $\alpha$ used to denote the intercept instead of $b_0$  

:::


## back to our example {.smaller}

::::{.columns}
:::{.column width="50%"}
> Are older people more satisfied with life? 112 people from 12 different dwellings (cities/towns) in Scotland. Information on their ages and some measure of life satisfaction.  

```{r}
#| echo: true
d3 <- read_csv("../../../data/d3lmm.csv") 
head(d3)
```

:::

:::{.column width="50%"}
```{r}
ggplot(d3,aes(x=age,y=lifesat))+
  geom_point(size=4,alpha=.3)+
  facet_wrap(~dwelling)
```

:::
::::

## estimate the differences {.smaller}

::::{.columns}
:::{.column width="50%"}
the fixed effects approach:  

```{r}
#| echo: true
mod <- lm(lifesat ~ 1 + dwelling + age, data = d3)
summary(mod)
```

:::
:::{.column width="50%"}
```{r}
library(ggforce)
library(ggfx)
femod = lm(lifesat~1+dwelling+age,d3 |> mutate(age=age/10))
basep = ggplot(d3 |> mutate(age=age/10), 
               aes(x=age,y=lifesat))+
  geom_point(size=3,alpha=.2,aes(col=dwelling)) +
  guides(col="none")+
  geom_vline(xintercept=0,lty="dashed")+
  scale_x_continuous(limits=c(-1,7),breaks=c(0:6),labels=seq(0,60,10))+
  scale_y_continuous(limits=c(-10,85),breaks=c(0,20,40,60,80))

plotlabs = tibble(dwelling=unique(d3$dwelling),age=6,x=6)
plotlabs$y = predict(femod, newdata=plotlabs)

plotlines = 
  expand_grid(dwelling=unique(d3$dwelling),age=0:6) %>%
  mutate(
    .fitted = predict(femod, newdata = .)
  )
  
basep + 
  with_blur(geom_line(data = broom::augment(femod), aes(y=.fitted,group=dwelling),alpha=.3),sigma=2) + 
  geom_text(data=plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3)+
  geom_line(data = plotlines[plotlines$dwelling=="Aberdeen",], aes(y=.fitted,group=dwelling),col="blue") +
  geom_label(data=plotlabs[grepl("Aberd",plotlabs$dwelling),],
             aes(x=x,y=y,label=dwelling),
             hjust=0,col="blue")+
  geom_point(aes(x=0,y=coef(femod)[1]),size=3,col="blue")
```

:::
::::


## estimate the differences {.smaller visibility="uncounted"}

::::{.columns}
:::{.column width="50%"}
the fixed effects approach:  

```{r}
#| echo: true
mod <- lm(lifesat ~ 1 + dwelling + age, data = d3)
summary(mod)
```


:::

:::{.column width="50%"}
```{r}
twoplot = plotlines |> filter(grepl("Aberd|Glasg",dwelling),age==1)

basep + 
  with_blur(geom_line(data = broom::augment(femod), aes(y=.fitted,group=dwelling),alpha=.3),sigma=2) + 
  geom_text(data=plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3)+
  geom_point(aes(x=0,y=coef(femod)[1]),size=3,col="blue") +
  geom_line(data = plotlines[plotlines$dwelling=="Aberdeen",], aes(y=.fitted,group=dwelling),col="blue") +
  geom_label(data=plotlabs[grepl("Aberd",plotlabs$dwelling),],
             aes(x=x,y=y,label=dwelling),
             hjust=0,col="blue")+
  geom_line(data = plotlines[plotlines$dwelling=="Glasgow",], aes(y=.fitted,group=dwelling),col="blue") +
  geom_label(data=plotlabs[grepl("Glasgow",plotlabs$dwelling),],
             aes(x=x,y=y,label=dwelling),
             hjust=0,col="blue") +
  geom_line(data = twoplot,
               aes(x=age,y=.fitted),col="blue",lty="dashed")+
  annotate("text",x=1,y=mean(twoplot$.fitted),
           label=expression(beta["dwellingGlasgow"]),size=8,
           hjust=0,col="blue")
```

:::
::::

## estimate the differences {.smaller visibility="uncounted"}

::::{.columns}
:::{.column width="50%"}
the fixed effects approach:  

```{r}
#| echo: true
mod <- lm(lifesat ~ 1 + dwelling + age, data = d3)
summary(mod)
```


:::

:::{.column width="50%"}

```{r}
twoplot = plotlines |> filter(grepl("Aberd|Dumfrie",dwelling),age==2)

basep + 
  with_blur(geom_line(data = broom::augment(femod), aes(y=.fitted,group=dwelling),alpha=.3),sigma=2) + 
  geom_text(data=plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3)+
  geom_point(aes(x=0,y=coef(femod)[1]),size=3,col="blue") +
  geom_line(data = plotlines[plotlines$dwelling=="Aberdeen",], aes(y=.fitted,group=dwelling),col="blue") +
  geom_label(data=plotlabs[grepl("Aberd",plotlabs$dwelling),],
             aes(x=x,y=y,label=dwelling),
             hjust=0,col="blue")+
  geom_line(data = plotlines[plotlines$dwelling=="Dumfries",], aes(y=.fitted,group=dwelling),col="blue") +
  geom_label(data=plotlabs[grepl("Dumfries",plotlabs$dwelling),],
             aes(x=x,y=y,label=dwelling),
             hjust=0,col="blue") +
  geom_line(data = twoplot,
               aes(x=age,y=.fitted),col="blue",lty="dashed")+
  annotate("text",x=2,y=mean(twoplot$.fitted),
           label=expression(beta["dwellingDumfries"]),size=8,
           hjust=0,col="blue")
```

:::
::::


## estimate the differences {.smaller visibility="uncounted"}

::::{.columns}
:::{.column width="50%"}
the fixed effects approach:  

```{r}
#| echo: true
mod <- lm(lifesat ~ 1 + dwelling + age, data = d3)
summary(mod)
```

:::

:::{.column width="50%"}

```{r}
twoplot = plotlines |> filter(grepl("Aberd|Kirkcal",dwelling),age==2)

basep + 
  with_blur(geom_line(data = broom::augment(femod), aes(y=.fitted,group=dwelling),alpha=.3),sigma=2) + 
  geom_text(data=plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3)+
  geom_point(aes(x=0,y=coef(femod)[1]),size=3,col="blue") +
  geom_line(data = plotlines[plotlines$dwelling=="Aberdeen",], aes(y=.fitted,group=dwelling),col="blue") +
  geom_label(data=plotlabs[grepl("Aberd",plotlabs$dwelling),],
             aes(x=x,y=y,label=dwelling),
             hjust=0,col="blue")+
  geom_line(data = plotlines[plotlines$dwelling=="Kirkcaldy",], aes(y=.fitted,group=dwelling),col="blue") +
  geom_label(data=plotlabs[grepl("Kirkcaldy",plotlabs$dwelling),],
             aes(x=x,y=y,label=dwelling),
             hjust=0,col="blue") +
  geom_line(data = twoplot,
               aes(x=age,y=.fitted),col="blue",lty="dashed")+
  annotate("text",x=2,y=mean(twoplot$.fitted),
           label=expression(beta["dwellingKirkcaldy"]),size=8,
           hjust=0,col="blue")
```

:::
::::

## deviations from an average 

::::{.columns}
:::{.column width="50%"}

Group deviations from an overall average

:::

:::{.column width="50%"}
```{r}
library(lme4)
rimod = lmer(lifesat~1+age+(1|dwelling),d3 |> mutate(age=age/10))

plotlabs = tibble(dwelling=unique(d3$dwelling),age=6,x=6)
plotlabs$y = predict(rimod, newdata=plotlabs)

plotlines = 
  as.data.frame(coef(rimod)$dwelling) |> 
  rownames_to_column() |>
  mutate(
    g = 1:n(),
    data = map2(`(Intercept)`,age, ~tibble(x = 0:6, .fitted = ..1 + ..2*(0:6)))
  ) |> unnest(data)

specg = plotlines |> filter(g==12) |>
  mutate(f = fixef(rimod)[1])

basep + 
  with_blur(geom_line(data = plotlines, aes(x=x,y=.fitted,group=g),alpha=.3),sigma=2) + 
  geom_abline(intercept=fixef(rimod)[1],slope=fixef(rimod)['age'],
              lwd=1,col="#a41ae4") +
  geom_point(x=0,y=fixef(rimod)[1],size=3,col="#a41ae4")+
  
  geom_line(data = specg,lwd=1,
            aes(x=x,y=.fitted,group=g),alpha=1,col="darkorange3") +
  geom_curve(
    data=specg[1,],
    aes(x=0,xend=0,y=.fitted,yend=f),col="darkorange3",
    curvature=.2,lwd=1
  ) +
  annotate("text",x=-.1,y=mean(unlist(specg[1,c(6,7)])),
           label=expression(zeta["0Strlng"]),size=8,
           hjust=1,col="darkorange3")+
  geom_text(data=plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3)+
  geom_label(data=plotlabs[grepl("Stirling",plotlabs$dwelling),],
             aes(x=x,y=y,label=dwelling),
             hjust=0,col="darkorange3")+
  guides(col="none")
```
:::
::::

## deviations from an average {visibility="uncounted"}

::::{.columns}
:::{.column width="50%"}

Group deviations from an overall average

:::

:::{.column width="50%"}
```{r}
specg = plotlines |> filter(g==1) |>
  mutate(f = fixef(rimod)[1])

basep + 
  with_blur(geom_line(data = plotlines, aes(x=x,y=.fitted,group=g),alpha=.3),sigma=2) + 
  geom_abline(intercept=fixef(rimod)[1],slope=fixef(rimod)['age'],
              lwd=1,col="#a41ae4") +
  geom_point(x=0,y=fixef(rimod)[1],size=3,col="#a41ae4")+
  
  geom_line(data = specg,lwd=1,
            aes(x=x,y=.fitted,group=g),alpha=1,col="darkorange3") +
  geom_curve(
    data=specg[1,],
    aes(x=0,xend=0,y=.fitted,yend=f),col="darkorange3",
    curvature=-.2,lwd=1
  )  +
  annotate("text",x=-.1,y=mean(unlist(specg[1,c(6,7)])),
           label=expression(zeta["0Abdn"]),size=8,
           hjust=1,col="darkorange3")+
  geom_text(data=plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3)+
  geom_label(data=plotlabs[grepl("Aberde",plotlabs$dwelling),],
             aes(x=x,y=y,label=dwelling),
             hjust=0,col="darkorange3")+
  guides(col="none")
```
:::
::::

## deviations from an average {visibility="uncounted"}

::::{.columns}
:::{.column width="50%"}

Group deviations from an overall average

:::

:::{.column width="50%"}
```{r}
specg = plotlines |> filter(g==7) |>
  mutate(f = fixef(rimod)[1])

basep + 
  with_blur(geom_line(data = plotlines, aes(x=x,y=.fitted,group=g),alpha=.3),sigma=2) + 
  geom_abline(intercept=fixef(rimod)[1],slope=fixef(rimod)['age'],
              lwd=1,col="#a41ae4") +
  geom_point(x=0,y=fixef(rimod)[1],size=3,col="#a41ae4")+
  
  geom_line(data = specg,lwd=1,
            aes(x=x,y=.fitted,group=g),alpha=1,col="darkorange3") +
  geom_curve(
    data=specg[1,],
    aes(x=0,xend=0,y=.fitted,yend=f),col="darkorange3",
    curvature=.2,lwd=1
  ) +
  annotate("text",x=-.1,y=mean(unlist(specg[1,c(6,7)])),
           label=expression(zeta["0Glsgw"]),size=8,
           hjust=1,col="darkorange3")+
  geom_text(data=plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3)+
  geom_label(data=plotlabs[grepl("Glasg",plotlabs$dwelling),],
             aes(x=x,y=y,label=dwelling),
             hjust=0,col="darkorange3")+
  guides(col="none")
```
:::
::::

## v2 deviations from an average 

::::{.columns}
:::{.column width="50%"}

Group deviations from an overall average

:::

:::{.column width="50%"}
```{r}
library(lme4)
rimod = lmer(lifesat~1+age+(1|dwelling),d3 |> mutate(age=age/10))
femod = lm(lifesat~1+age+dwelling,d3 |> mutate(age=age/10), 
           contrasts=list(dwelling="contr.sum"))

gnums = tibble(dwelling=rownames(as.data.frame(coef(rimod)$dwelling))) |>
  mutate(g=1:n())

plotlines = 
  expand_grid(dwelling=unique(d3$dwelling),age=0:6) %>%
  mutate(
    x=age,
    .fitted = predict(femod, newdata = .)
  ) |> left_join(gnums)
plotlabs = tibble(dwelling=unique(d3$dwelling),age=6,x=6)
plotlabs$y = predict(femod, newdata=plotlabs)

specg = plotlines |> filter(g==12) |>
  mutate(f = coef(femod)[1])

basep + 
  with_blur(geom_line(data = plotlines, aes(x=x,y=.fitted,group=g),alpha=.3),sigma=2) + 
  geom_abline(intercept=coef(femod)[1],slope=coef(femod)['age'],
              lwd=1,col="#a41ae4") +
  geom_point(x=0,y=coef(femod)[1],size=3,col="#a41ae4")+
  
  geom_line(data = specg,lwd=1,
            aes(x=x,y=.fitted,group=g),alpha=1,col="darkorange3") +
  geom_curve(
    data=specg[1,],
    aes(x=0,xend=0,y=.fitted,yend=f),col="darkorange3",
    curvature=.2,lwd=1
  ) +
  annotate("text",x=-.1,y=mean(unlist(specg[1,c(4,6)])),
           label=expression("d"["Strlng"]),size=8,
           hjust=1,col="darkorange3")+
  geom_text(data=plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3)+
  geom_label(data=plotlabs[grepl("Stirling",plotlabs$dwelling),],
             aes(x=x,y=y,label=dwelling),
             hjust=0,col="darkorange3")+
  guides(col="none")
```
:::
::::

## v2 deviations from an average {visibility="uncounted"}

::::{.columns}
:::{.column width="50%"}

Group deviations from an overall average

:::

:::{.column width="50%"}
```{r}
specg = plotlines |> filter(g==1) |>
  mutate(f = coef(femod)[1])

basep + 
  with_blur(geom_line(data = plotlines, aes(x=x,y=.fitted,group=g),alpha=.3),sigma=2) + 
  geom_abline(intercept=coef(femod)[1],slope=coef(femod)['age'],
              lwd=1,col="#a41ae4") +
  geom_point(x=0,y=coef(femod)[1],size=3,col="#a41ae4")+
  
  geom_line(data = specg,lwd=1,
            aes(x=x,y=.fitted,group=g),alpha=1,col="darkorange3") +
  geom_curve(
    data=specg[1,],
    aes(x=0,xend=0,y=.fitted,yend=f),col="darkorange3",
    curvature=-.2,lwd=1
  ) +
  annotate("text",x=-.1,y=mean(unlist(specg[1,c(4,6)])),
           label=expression("d"["Abdn"]),size=8,
           hjust=1,col="darkorange3")+
  geom_text(data=plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3)+
  geom_label(data=plotlabs[grepl("Aberde",plotlabs$dwelling),],
             aes(x=x,y=y,label=dwelling),
             hjust=0,col="darkorange3")+
  guides(col="none")
```
:::
::::

## v2 deviations from an average {visibility="uncounted"}

::::{.columns}
:::{.column width="50%"}

Group deviations from an overall average

:::

:::{.column width="50%"}
```{r}
specg = plotlines |> filter(g==7) |>
  mutate(f = coef(femod)[1])

basep + 
  with_blur(geom_line(data = plotlines, aes(x=x,y=.fitted,group=g),alpha=.3),sigma=2) + 
  geom_abline(intercept=coef(femod)[1],slope=coef(femod)['age'],
              lwd=1,col="#a41ae4") +
  geom_point(x=0,y=coef(femod)[1],size=3,col="#a41ae4")+
  
  geom_line(data = specg,lwd=1,
            aes(x=x,y=.fitted,group=g),alpha=1,col="darkorange3") +
  geom_curve(
    data=specg[1,],
    aes(x=0,xend=0,y=.fitted,yend=f),col="darkorange3",
    curvature=.2,lwd=1
  ) +
  annotate("text",x=-.1,y=mean(unlist(specg[1,c(4,6)])),
           label=expression("d"["Glsgw"]),size=8,
           hjust=1,col="darkorange3")+
  geom_text(data=plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3)+
  geom_label(data=plotlabs[grepl("Glasg",plotlabs$dwelling),],
             aes(x=x,y=y,label=dwelling),
             hjust=0,col="darkorange3")+
  guides(col="none")
```
:::
::::

## the multilevel model: a model of models


::::{.columns}
:::{.column width="50%"}
modelling group-level variability, rather than estimating group differences. 
:::

:::{.column width="50%"}

```{r}
#| echo: false
library(lme4)
library(ggside)
library(ggdist)
library(distributional)
rimod = lmer(lifesat~1+age+(1|dwelling),d3 |> mutate(age=age/10))

plotlabs = tibble(dwelling=unique(d3$dwelling),age=6,x=6)
plotlabs$y = predict(rimod, newdata=plotlabs)

plotlines = 
  as.data.frame(coef(rimod)$dwelling) |> 
  rownames_to_column() |>
  mutate(
    g = 1:n(),
    data = map2(`(Intercept)`,age, ~tibble(x = 0:6, .fitted = ..1 + ..2*(0:6)))
  ) |> unnest(data)

basep + 
  with_blur(geom_line(data = plotlines, aes(x=x,y=.fitted,group=g),alpha=.2), sigma=2) + 
  stat_eye(side="left",
           data=tibble(age=-1,lifesat=fixef(rimod)[1]),
           aes(x=0,ydist=dist_normal(fixef(rimod)[1],sqrt(VarCorr(rimod)[[1]][1]))), 
           alpha=.3, fill="#a41ae4")+
  geom_abline(intercept=fixef(rimod)[1],slope=fixef(rimod)[2], lwd=1,col="#a41ae4")+
    geom_text(data=plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3) +
  annotate("text",x=-.1,y=fixef(rimod)[1],
           label=expression(gamma["00"]),size=8,
           hjust=-.25,vjust=1.2,col="#a41ae4",parse=TRUE) +
  geom_segment(x=0,xend=0,y=fixef(rimod)[1],
               yend=fixef(rimod)[1]+sqrt(VarCorr(rimod)[[1]][1]),
               col="darkorange3",lwd=1) +
  annotate("text",x=-.1,y=30,
           label=expression(sigma["0"]),size=8,
           hjust=1,col="darkorange3")
```
:::
::::


## the multilevel model

::::{.columns}
:::{.column width="50%"}
::: {style="width:0; float:left;"}
$$
\begin{align}
& \text{for observation }j\text{ in group }i \\
\quad \\
& \text{Level 1:} \\
& \color{red}{y_{ij}} = \color{blue}{b_{0i} \cdot 1 + b_{1} \cdot x_{ij}} + \varepsilon_{ij} \\
& \text{Level 2:} \\
& \color{blue}{b_{0i}} = \gamma_{00} + \color{orange}{\zeta_{0i}} \\
\quad \\
& \color{orange}{\zeta_{0i}} \sim N(0,\color{orange}{\sigma_0}) \\
& \varepsilon_{ij} \sim N(0,\sigma_\varepsilon) \\
\end{align}
$$
:::
:::

:::{.column width="50%"}

```{r}
#| echo: false
basep + 
  with_blur(geom_line(data = plotlines, aes(x=x,y=.fitted,group=g),alpha=.2), sigma=2) + 
  stat_eye(side="left",
           data=tibble(age=-1,lifesat=fixef(rimod)[1]),
           aes(x=0,ydist=dist_normal(fixef(rimod)[1],sqrt(VarCorr(rimod)[[1]][1]))), 
           alpha=.3, fill="#a41ae4")+
  geom_abline(intercept=fixef(rimod)[1],slope=fixef(rimod)[2], lwd=1,col="#a41ae4")+
    geom_text(data=plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3) +
  annotate("text",x=-.1,y=fixef(rimod)[1],
           label=expression(gamma["00"]),size=8,
           hjust=-.25,vjust=1.2,col="#a41ae4",parse=TRUE) +
  geom_segment(x=0,xend=0,y=fixef(rimod)[1],
               yend=fixef(rimod)[1]+sqrt(VarCorr(rimod)[[1]][1]),
               col="darkorange3",lwd=1) +
  annotate("text",x=-.1,y=30,
           label=expression(sigma["0"]),size=8,
           hjust=1,col="darkorange3")
```

:::
::::


## the multilevel model {visibility="uncounted"}

::::{.columns}
:::{.column width="50%"}
::: {style="width:0; float:left;"}
$$
\begin{align}
& \text{for observation }j\text{ in }\textbf{Edinburgh} \\
\quad \\
& \text{Level 1:} \\
& \color{red}{y_{Edb,j}} = \color{blue}{b_{0Edb} \cdot 1 + b_{1} \cdot x_{Edb,j}} + \varepsilon_{Edb,j} \\
& \text{Level 2:} \\
& \color{blue}{b_{0Edb}} = \gamma_{00} + \color{orange}{\zeta_{0Edb}} \\
\quad \\
& \color{orange}{\zeta_{0i}} \sim N(0,\color{orange}{\sigma_0}) \\
& \varepsilon_{ij} \sim N(0,\sigma_\varepsilon) \\
\end{align}
$$
:::
:::

:::{.column width="50%"}

```{r}
#| echo: false
specg = plotlines |> filter(g==5) |>
  mutate(f = fixef(rimod)[1])

basep + 
  with_blur(geom_line(data = plotlines, aes(x=x,y=.fitted,group=g),alpha=.2), sigma=2) + 
  stat_eye(side="left",
           data=tibble(age=-1,lifesat=fixef(rimod)[1]),
           aes(x=0,ydist=dist_normal(fixef(rimod)[1],sqrt(VarCorr(rimod)[[1]][1]))), 
           alpha=.3, fill="#a41ae4")+
  geom_abline(intercept=fixef(rimod)[1],slope=fixef(rimod)[2], lwd=1,col="#a41ae4")+
    geom_text(data=plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3) +
  annotate("text",x=-.1,y=fixef(rimod)[1],
           label=expression(gamma["00"]),size=8,
           hjust=-.25,vjust=1.2,col="#a41ae4",parse=TRUE) +
  geom_segment(x=0,xend=0,y=fixef(rimod)[1],
               yend=fixef(rimod)[1]-sqrt(VarCorr(rimod)[[1]][1]),
               col="darkorange3",lwd=1) +
  annotate("text",x=-.1,y=20,
           label=expression(sigma["0"]),size=8,
           hjust=1,col="darkorange3")+
  
  geom_line(data = specg,lwd=1,
            aes(x=x,y=.fitted,group=g),alpha=1,col="darkorange3") +
  geom_curve(
    data=specg[1,],
    aes(x=0,xend=0,y=.fitted,yend=f),col="darkorange3",
    curvature=.2,lwd=1
  ) +
  annotate("text",x=-.1,y=mean(unlist(specg[1,c(6,7)])),
           label=expression(zeta["0Edb"]),size=8,
           hjust=1,col="darkorange3")+
  geom_text(data=plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3)+
  geom_label(data=plotlabs[grepl("Edinb",plotlabs$dwelling),],
             aes(x=x,y=y,label=dwelling),
             hjust=0,col="darkorange3")
```

:::
::::


## random intercepts

::::{.columns}
:::{.column width="50%"}
::: {style="width:0; float:left;"}
$$
\begin{align}
& \text{for observation }j\text{ in group }i \\
\quad \\
& \text{Level 1:} \\
& \color{red}{y_{ij}} = \color{blue}{b_{0i} \cdot 1 + b_{1} \cdot x_{ij}} + \varepsilon_{ij} \\
& \quad \\
& \text{Level 2:} \\
& \color{blue}{b_{0i}} = \gamma_{00} + \color{orange}{\zeta_{0i}} \\
\end{align}
$$
:::
:::

:::{.column width="50%" style="font-size: 70%;color:#999999"}
<br>
for observation $j$ **from group $i$**,  
<br><br>
their value of $\color{red}{y}$ =   
&nbsp;&nbsp;some number **for group $i$** ($\color{blue}{b_{0i}}$) +  
&nbsp;&nbsp;some amount ($\color{blue}{b_1}$) times their value of $x$ +  
&nbsp;&nbsp;their residual $\varepsilon_{ij}$  
<br>
group $i$'s intercept ($\color{blue}{b_{0i}}$) =  
&nbsp;&nbsp;the intercept for the average of the population of groups ($\gamma_{00}$)  
&nbsp;&nbsp;the deviation of group $i$ ($\color{orange}{\zeta_{0i}}$) from $\gamma_{00}$  

:::
::::

## random slopes

::::{.columns}
:::{.column width="50%"}
::: {style="width:0; float:left;"}
$$
\begin{align}
& \text{for observation }j\text{ in group }i \\
\quad \\
& \text{Level 1:} \\
& \color{red}{y_{ij}} = \color{blue}{b_{0i} \cdot 1 + b_{1i} \cdot x_{ij}} + \varepsilon_{ij} \\
& \quad \\
& \text{Level 2:} \\
& \color{blue}{b_{0i}} = \gamma_{00} + \color{orange}{\zeta_{0i}} \\
& \color{blue}{b_{1i}} = \gamma_{10} + \color{orange}{\zeta_{1i}} \\
\end{align}
$$
:::
:::

:::{.column width="50%" style="font-size: 70%;color:#999999"}
<br>
for observation $j$ **from group $i$**,  
<br><br>
their value of $\color{red}{y}$ =   
&nbsp;&nbsp;some number **for group $i$** ($\color{blue}{b_{0i}}$) +  
&nbsp;&nbsp;some amount **for group $i$** ($\color{blue}{b_1i}$) times their value of $x$ +  
&nbsp;&nbsp;their residual $\varepsilon_{ij}$  
<br>
group $i$'s intercept ($\color{blue}{b_{0i}}$) =  
&nbsp;&nbsp;the intercept for the average of the population of groups ($\gamma_{00}$)  
&nbsp;&nbsp;the deviation of group $i$ ($\color{orange}{\zeta_{0i}}$) from $\gamma_{00}$  
group $i$'s slope ($\color{blue}{b_{1i}}$) =  
&nbsp;&nbsp;the slope for the average of the population of groups ($\gamma_{10}$)  
&nbsp;&nbsp;the deviation of group $i$ ($\color{orange}{\zeta_{1i}}$) from $\gamma_{10}$  
  
:::
::::

## random slopes  

::::{.columns}
:::{.column width="50%"}
$$
\begin{align}
& \text{for observation }j\text{ in group }i \\
\quad \\
& \text{Level 1:} \\
& \color{red}{y_{ij}} = \color{blue}{\beta_{0i} \cdot 1 + \beta_{1i} \cdot x_{ij}} + \varepsilon_{ij} \\
& \text{Level 2:} \\
& \color{blue}{\beta_{0i}} = \gamma_{00} + \color{orange}{\zeta_{0i}} \\
& \color{blue}{\beta_{1i}} = \gamma_{10} + \color{orange}{\zeta_{1i}} \\
\quad \\
& \text{Where:} \\
& \gamma_{00}\text{ is the population intercept, and }\color{orange}{\zeta_{0i}}\text{ is the deviation of group }i\text{ from }\gamma_{00} \\
& \gamma_{10}\text{ is the population slope, and }\color{orange}{\zeta_{1i}}\text{ is the deviation of group }i\text{ from }\gamma_{10} \\
\end{align}
$$
:::

:::{.column width="50%"}


:::
::::



## the multilevel model: partial pooling


::::{.columns}
:::{.column width="50%"}

- Remember - in a no-pooling approach, information is not combined in anyway (data from cluster $i$ contributes to differences from reference cluster to cluster $i$, but nothing else.  
    - Information from Glasgow, Edinburgh, Perth, Stirling etc doesn't influence what we think about Kirkcaldy.  
    
:::

:::{.column width="50%"}

- In the multilevel model, we model group deviations as normally distributed with a variance of $\color{orange}{\sigma_0}$.  
    - so we expect fewer groups to be really far away from the average

:::
::::



## the multilevel model: partial pooling {transition="slide"}


::::{.columns}
:::{.column width="50%"}

- In the multilevel model, we model group deviations as normally distributed with a variance of $\color{orange}{\sigma_0}$.  
    - so we expect fewer groups to be really far away from the average
    
:::

:::{.column width="50%"}


```{r}
#| eval: false
femod = lm(lifesat~1+age+dwelling,d3 |> mutate(age=age/10))
rimod = lmer(lifesat~1+age+(1|dwelling),d3 |> mutate(age=age/10))

plotlabs = tibble(dwelling=unique(d3$dwelling),age=6,x=6)
plotlabs$y = predict(rimod, newdata=plotlabs)

plotlines = 
  as.data.frame(coef(rimod)$dwelling) |> 
  rownames_to_column() |>
  mutate(
    g = 1:n(),
    data = map2(`(Intercept)`,age, ~tibble(x = 0:6, .fitted = ..1 + ..2*(0:6)))
  ) |> unnest(data)

plotlinesF = 
  expand_grid(dwelling=unique(d3$dwelling),age=0:6) %>%
  mutate(
    x=age,
    .fitted = predict(femod, newdata = .)
  )

anim_plotlines = bind_rows(
  plotlines |> mutate(dwelling=rowname) |>
    select(dwelling,g,x,.fitted) |> mutate(f = 1),
  plotlinesF |> select(dwelling,x,.fitted) |> mutate(f = 0)
) |> group_by(dwelling) |>
  mutate(g=mean(g,na.rm=T)) |> ungroup()

plotlabsF = tibble(dwelling=unique(d3$dwelling),age=6,x=6)
plotlabsF$y = predict(femod, newdata=plotlabsF)
anim_plotlabs = bind_rows(plotlabs |> mutate(f=1),
                          plotlabsF |> mutate(f=0))

anim_dist = tibble(age=-1,lifesat=fixef(rimod)[1],
       x=0,m=c(mean(plotlinesF$.fitted[plotlinesF$x==0]),
               fixef(rimod)[1]),
       s=c(1e3,sqrt(VarCorr(rimod)[[1]][1])),
       f = 0:1
)

  
library(gganimate)
animp = basep + 
  with_blur(geom_line(data = anim_plotlines,
                      aes(x=x,y=.fitted,group=g),alpha=.2), sigma=2) + 
  geom_line(data = anim_plotlines |> filter(dwelling=="Kirkcaldy"),
            aes(x=x,y=.fitted,group=g)) +
  geom_point(data = d3 |> filter(dwelling=="Kirkcaldy") |>
               mutate(age=age/10),
            aes(x=age,y=lifesat,col=dwelling),size=3) +
  geom_text(data=anim_plotlabs,
             aes(x=x,y=y,label=dwelling),
             hjust=0,alpha=.3) +
  stat_eye(side="left",
           data=anim_dist,
           aes(x=x,ydist=dist_normal(m,s)), 
           alpha=.3, fill="#a41ae4")+
  
  transition_states(f)+
  ease_aes('sine-in-out')
  
anim_save("output.gif",animp)
```

:::
::::





## fixed and random {.smaller}

::::{.columns}
:::{.column width="50%"}


$\begin{align}& \text{Level 1:} \\ & \color{red}{y_{ij}} = \color{blue}{\beta_{0i} \cdot 1 + \beta_{1i} \cdot x_{1ij} + \beta_2 \cdot x_{2ij}} + \varepsilon_{ij} \\ & \text{Level 2:} \\ & \color{blue}{\beta_{0i}} = \underbrace{\gamma_{00}}_{\textrm{fixed}} + \color{orange}{\underbrace{\zeta_{0i}}_{\textrm{random}}} \\ & \color{blue}{\beta_{1i}} = \underbrace{\gamma_{10}}_{\textrm{fixed}} + \color{orange}{\underbrace{\zeta_{1i}}_{\textrm{random}}} \\ \quad \\ \end{align}$

:::

:::{.column width="50%"}

$\color{red}{y_{ij}} = (\underbrace{\gamma_{00}}_{\textrm{fixed}} + \color{orange}{\underbrace{\zeta_{0i}}_{\textrm{random}}}) \cdot 1 + (\underbrace{\gamma_{10}}_{\textrm{fixed}} + \color{orange}{\underbrace{\zeta_{1i}}_{\textrm{random}}}) \cdot x_{1ij} + \underbrace{\beta_2}_{\textrm{fixed}} \cdot x_{2ij} +  \varepsilon_{ij} \\$

:::
::::

The $\color{orange}{\zeta}$ components also get termed the "random effects" part of the model, Hence names like "random effects model", etc.

$\color{orange}{\zeta_i}$ is "random" because considered a random sample from larger population such that $\color{orange}{\zeta_i} \sim N(0, \sigma^2_{\color{orange}{\zeta_i}})$. 


## fixed and random {.smaller}

I have groups in my data, should I:  

a. include group as a fixed effect predictor $\color{blue}{\beta \cdot Group}$  
b. consider the groups to be 'clusters' and include group-level random effects $\color{orange}{\zeta_{i}}$

| Criterion: | Repetition: <br> _If the experiment were repeated:_ | Desired inference: <br> _The conclusions refer to:_ |
|----------------|--------------------------------------------------|----------------------------------------------------|
| Fixed effects  | Same levels would be used     |   The levels used                                    |
| Random effects | Different levels would be used   | A population from which the levels used<br> are just a (random) sample |


Practical points:  

- Sometimes there isn't enough variability between groups to model random effects. 
  - $\sigma^2_{\color{orange}{\zeta}}$ gets estimated as (too close to) zero.
- Sometimes you might not have sufficient data (e.g. only have 4 'clusters'). 
  - estimate of $\sigma^2_{\color{orange}{\zeta}}$ needs sufficient $n$ 
  
## Advantages of MLM {.smaller}

Multi-level models can be used to answer multi-level questions!  
<br><br>
Do phenomena at Level X predict __outcomes__ at Level Y?  

__example:__  
$n$ participants, each completes reaction time task multiple times.  
Q: Does handedness (L vs R) predict variation in reaction times?  

$$
\begin{align}
\textrm{for person }i\textrm{, observation }j \\
\textrm{reaction time}_{ij} &= \beta_{0i} + \varepsilon_{ij} \\
\beta_{0i} &= \gamma_{00} + \zeta_{0i} + \gamma_{01}\textrm{handedness}_i
\end{align}
$$
<br>
Single equation:  
$$
\begin{equation}
\textrm{reaction time}_{ij} = (\gamma_{00} + \zeta_{0i}) + \gamma_{01}\textrm{handedness}_i + \varepsilon_{ij}
\end{equation}
$$

## Advantages of MLM {.smaller}

Multi-level models can be used to answer multi-level questions!  
<br><br>
Do phenomena at Level X influence __effects__ at Level Y?  

__example:__  
$n$ children's grades are recorded every year throughout school  
Q: Does being mono/bi-lingual influence childrens' grades over the duration of their schooling?  

$$
\begin{align}
\textrm{for child }i\textrm{, in year }j \\
\textrm{grade}_{ij} &= \beta_{0} + \beta_{1i}\textrm{school year}_{ij} + \varepsilon_{ij} \\  
\beta_{1i} &= \gamma_{10} + \zeta_{1i} + \gamma_{11}\textrm{bilingual}_i
\end{align}
$$

<br>
Single equation:   
$$
\begin{equation}
\textrm{grade}_{ij} = \beta_{0} + (\gamma_{10} + \zeta_{1i})\cdot\textrm{school year}_{ij} + \gamma_{11}\textrm{bilingual}_i\cdot\textrm{school year}_{ij} + \varepsilon_{ij}
\end{equation}
$$


## Advantages of MLM {.smaller}

Multi-level models can be used to answer multi-level questions!  
<br><br>
Do random variances covary?  

__example:__  
$n$ participants' cognitive ability is measured across time.  
Q: Do people who have higher cognitive scores at start of study show less decline over the study period than those who have lower scores?  

$$
\begin{align}
\textrm{for person }i\textrm{, at time }j \\
\textrm{cognition}_{ij} &= \beta_{0i} + \beta_{1i}\textrm{time}_{ij} + \varepsilon_{ij} \\
\beta_{0i} &= \gamma_{00} + \zeta_{0i}\\
\beta_{1i} &= \gamma_{10} + \zeta_{1i}\\
\end{align}
$$
$$
\begin{equation}
\begin{bmatrix} \zeta_{0i} \\ \zeta_{1i} \end{bmatrix}
\sim N
\left(
    \begin{bmatrix} 0 \\ 0 \end{bmatrix},
    \begin{bmatrix}
        \sigma_0^2 & \rho \sigma_0 \sigma_1 \\
        \rho \sigma_0 \sigma_1 & \sigma_1^2
    \end{bmatrix}
\right)
\end{equation}
$$


## The lme4 package {.smaller}

- **lme4** package (many others are available, but **lme4** is most popular).  

- `lmer()` function.  

- syntax is similar to `lm()`, in that we specify:   

    __*[outcome variable]*__ ~ __*[explanatory variables]*__, data = __*[name of dataframe]*__
    
- in `lmer()`, we add to this the random effect structure in parentheses:  

    __*[outcome variable]*__ ~ __*[explanatory variables]*__ + (__*[vary this]*__ | __*[by this grouping variable]*__),  
    data = __*[name of dataframe]*__, REML = __*[TRUE/FALSE]*__
    
    
```{r}
#| eval: false
#| echo: true
lmer(score ~ 1 + year + (1 + year | school), data = ...
```


## eg1 (Longitudinal): Data


::::{.columns}
:::{.column width="50%"}
> In a study examining how cognition changes over time, a sample of 20 participants took the Addenbrooke's Cognitive Examination (ACE) every 2 years from age 60 to age 78.  

Each participant has 10 datapoints. Participants are clusters.  

:::

:::{.column width="50%"}
```{r}
d3 <- read_csv("https://uoepsy.github.io/data/dapr3_mindfuldecline.csv")
head(d3)
```
:::
::::

## eg1: Data


::::{.columns}
:::{.column width="50%"}

> In a study examining how cognition changes over time, a sample of 20 participants took the Addenbrooke's Cognitive Examination (ACE) every 2 years from age 60 to age 78.  

```{r}
library(ICC)
ICCbare(x=ppt, y=ACE, data=d3)
```

__Reminder:__ the Intraclass Correlation Coefficient is ratio of variance between clusters to the total variance (variance within + variance between).


```{r echo=TRUE, fig.show='hide'}
pptplots <- 
  ggplot(d3, aes(x = visit, y = ACE, 
                  col = ppt)) +
  geom_point()+
  facet_wrap(~ppt) + 
  guides(col = "none") +
  labs(x = "visit", y = "cognition")
```
:::

:::{.column width="50%"}
```{r fig.asp=.9}
pptplots
```

:::
::::

## eg1: Fitting lm


::::{.columns}
:::{.column width="50%"}
```{r highlight.output=c(11,12)}
lm_mod <- lm(ACE ~ 1 + visit, data = d3)
summary(lm_mod)
```
:::

:::{.column width="50%" .fragment}
```{r}
#| echo: true
pptplots + 
  geom_line(aes(y=fitted(lm_mod)), col = "blue")
```

:::
::::


## eg1: Adding a random intercept


::::{.columns}
:::{.column width="50%"}
vary the intercept by participant.
```{r highlight.output=c(13,19)}
library(lme4)
ri_mod <- lmer(ACE ~ 1 + visit + 
                 (1 | ppt), data = d3)
summary(ri_mod)
```
:::

:::{.column width="50%" .fragment}
```{r}
#| echo: true
pptplots + 
  geom_line(aes(y=fitted(lm_mod)), col = "blue") + 
  geom_line(aes(y=fitted(ri_mod)), col = "red")
```
:::
::::


## eg1: Adding a random slope


::::{.columns}
:::{.column width="50%"}
vary the intercept and the slope (`ACE ~ visit`) by participants
```{r highlight.output=c(13,14,20,21)}
rs_mod <- lmer(ACE ~ 1 + visit + 
                 (1 + visit | ppt), data = d3)
summary(rs_mod)
```

:::

:::{.column width="50%" .fragment}
```{r}
#| echo: true
pptplots + 
  geom_line(aes(y=fitted(lm_mod)), col = "blue") + 
  geom_line(aes(y=fitted(ri_mod)), col = "red") + 
  geom_line(aes(y=fitted(rs_mod)), col = "orange")
```
:::
::::

## No Pooling?


::::{.columns}
:::{.column width="50%"}
Why not fit a fixed effect adjustment to the slope of x for each group?  
`lm(y ~ x * group)`?

```{r}
fe_mod <- lm(ACE ~ visit * ppt, data = d3)
```

:::

:::{.column width="50%"}
```{r}
#| echo: true
pptplots + 
  geom_line(aes(y=fitted(fe_mod)), col = "black")
```
:::
::::

## No Pooling vs Partial Pooling


::::{.columns}
:::{.column width="50%"}
- Remember - in the no-pooling approach, information is not combined in anyway (data from cluster $i$ contributes to differences from reference cluster to cluster $i$, but nothing else.  
Information in cluster 1 to 19 doesn't influence what the model thinks about cluster-20).  

- also, lots of output!  
```{r}
#| echo: true
length(coef(fe_mod))
```


:::

:::{.column width="50%" .fragment}
```{r echo=FALSE}
m1<-lm(ACE~visit*ppt, data = d3)
m2<-lmer(ACE~visit + (1 + visit | ppt), data = d3)
d3 %>% 
  mutate(
    lm_fit = fitted(m1),
    rs_fit = fitted(m2)
  ) %>%
  filter(ppt %in% paste0("PPT_",c(14,20,11,19))) %>%
  ggplot(., aes(x = visit)) + 
    geom_point(aes(y = ACE)) + 
    facet_wrap(~ppt,scales="free") +
    geom_line(aes(y = lm_fit, lty="fixed effects:\ny ~ x * g",col="fixed effects:\ny ~ x * g"), lwd=1) + 
    geom_line(aes(y = rs_fit, lty="random effects:\ny ~ x + (1 + x | g)", col="random effects:\ny ~ x + (1 + x | g)"), lwd=1) +
  scale_linetype_manual("model fitted values",values = c("fixed effects:\ny ~ x * g"=2,"random effects:\ny ~ x + (1 + x | g)"=1)) + 
  scale_color_manual("model fitted values",values = c("fixed effects:\ny ~ x * g"="black","random effects:\ny ~ x + (1 + x | g)"="orange"))+
  theme(legend.position="bottom")
```
:::
::::


## lmer output


::::{.columns}
:::{.column width="50%"}
```{r echo=FALSE, highlight.output=c(20,21)}
my_data<-read_csv("data/lme4output.csv")
m=lmer(y ~ x + (1 + x | group), my_data)
summary(m, correlation=F)
```
:::

:::{.column width="50%"}
```{r echo=FALSE}
knitr::include_graphics("img_sandbox/lmer2.png")
```
:::
::::


## lmer output


::::{.columns}
:::{.column width="50%"}
```{r echo=FALSE, highlight.output=c(13,14)}
my_data<-read_csv("data/lme4output.csv")
m=lmer(y ~ x + (1 + x | group), my_data)
summary(m, correlation=F)
```
:::

:::{.column width="50%"}
```{r echo=FALSE}
knitr::include_graphics("img_sandbox/lmer2a.png")
```
:::
::::

## lmer output


::::{.columns}
:::{.column width="50%"}
```{r echo=FALSE, highlight.output=c(13,14,20,21)}
my_data<-read_csv("data/lme4output.csv")
m=lmer(y ~ x + (1 + x | group), my_data)
summary(m, correlation=F)
```
:::

:::{.column width="50%"}
```{r echo=FALSE}
knitr::include_graphics("img_sandbox/lmer3.png")
```
:::
::::

## lmer output


::::{.columns}
:::{.column width="50%"}
```{r echo=FALSE, highlight.output=c(15)}
my_data<-read_csv("data/lme4output.csv")
m=lmer(y ~ x + (1 + x | group), my_data)
summary(m, correlation=F)
```
:::

:::{.column width="50%"}
```{r echo=FALSE}
knitr::include_graphics("img_sandbox/lmer4.png")
```
:::
::::

## Model Parameters


::::{.columns}
:::{.column width="50%"}
```{r echo=FALSE}
my_data<-read_csv("data/lme4output.csv")
model=lmer(y ~ x + (1 + x | group), my_data)
summary(model, correlation=F)
```
:::

:::{.column width="50%"}
Fixed effects:  
```{r}
fixef(model)
```

Variance components:  
```{r}
VarCorr(model)
```
:::
::::

## Model Predictions: ranef, coef


::::{.columns}
:::{.column width="50%"}
```{r echo=FALSE}
my_data<-read_csv("data/lme4output.csv") |> mutate(group=gsub("school","cluster_",group))
model=lmer(y ~ x + (1 + x | group), my_data)
summary(model, correlation=F)
```

:::

:::{.column width="50%"}
```{r}
#| eval: false
#| echo: true
ranef(model)
```
```{r echo=F}
head(ranef(model)$group %>% round(.,4), 5L) %>% rbind(.,"...") -> op
row.names(op)[6] <- "..."
op
```
```{r}
#| eval: false
#| echo: true
coef(model)
```
```{r echo=F}
head(coef(model)$group %>% round(.,4), 5L) %>% rbind(.,"...") -> op
row.names(op)[6] <- "..."
op
```

coef = fixef + ranef
:::
::::

## ICC from lmer


::::{.columns}
:::{.column width="50%"}
Fit an intercept-only model:  
```{r highlight.output=c(13,14)}
null_mod <- lmer(ACE ~ 1 + (1 | ppt), data = d3) 
summary(null_mod)
```
:::

:::{.column width="50%"}
```{r}
2.22 / (2.22 + 2.54)
```

Note: ICC is conditional on random intercepts only (inclusion of random slopes will affect your random intercept).  
:::
::::

