[
  {
    "objectID": "01_regressionrefresh.html",
    "href": "01_regressionrefresh.html",
    "title": "Regression Refresh and Clustered Data",
    "section": "",
    "text": "Preliminaries\n\nOpen Rstudio, and create a new project for this course!!\nCreate a new RMarkdown document or R script (whichever you like) for this week.\n\nThese are the main packages we’re going to use in this block. It might make sense to install them now if you do not have them already.\n\n\ntidyverse : for organising data\npatchwork: for organising plots\nICC : for quickly calculating intraclass correlation coefficient\nlme4 : for fitting generalised linear mixed effects models\nparameters : inference!\npbkrTest : more inference!\nHLMdiag : for examining case diagnostics at multiple levels\nlmeresampler : for bootstrapping!\neffects : for tables/plots\nsjPlot : for tables/plots\nbroom.mixed : tidying methods for mixed models\n\nYou can install all of these at once using:\n\ninstall.packages(c(\"tidyverse\",\"ICC\",\"lme4\",\"parameters\",\"pbkrTest\",\"effects\",\"broom.mixed\",\"sjPlot\",\"HLMdiag\"))\n# the lmeresampler package has had some recent updates. better to install the most recent version:\ninstall.packages(\"devtools\")\ndevtools::install_github(\"aloy/lmeresampler\")\n\n\n\nLinear Models & Pooling\n\nData: Wellbeing in Scotland\nIn DAPR2, one of the examples we used in learning about linear regression was in examining the relationship between time spent outdoors and mental wellbeing. In that example researchers had collected data from 32 residents of Edinburgh & Lothians.\nResearchers want to study this relationship across all of Scotland. They contact all the Local Authority Areas (LAAs) and ask them to collect data for them for them, with participants completing the Warwick-Edinburgh Mental Wellbeing Scale (WEMWBS), a self-report measure of mental health and well-being, and being asked to estimate the average number of hours they spend outdoors each week.\nTwenty of the Local Authority Areas provided data. It is available at https://uoepsy.github.io/data/LAAwellbeing.csv, and you can read it into your R environment using the code below:\n\nscotmw &lt;- read_csv(\"https://uoepsy.github.io/data/LAAwellbeing.csv\")\n\nThe dataset contains information on 132 participants. You can see the variables in the table below\n\n\n\n\n\n\n\n\n\nvariable\ndescription\n\n\n\n\nppt\nParticipant ID\n\n\nname\nParticipant Name\n\n\nlaa\nLocal Authority Area\n\n\noutdoor_time\nSelf report estimated number of hours per week spent outdoors\n\n\nwellbeing\nWarwick-Edinburgh Mental Wellbeing Scale (WEMWBS), a self-report measure of mental health and well-being. The scale is scored by summing responses to each item, with items answered on a 1 to 5 Likert scale. The minimum scale score is 14 and the maximum is 70.\n\n\ndensity\nLAA Population Density (people per square km)\n\n\n\n\n\n\n\n\n\nRegression Refresh\nRecall that in the DAPR2 course last year we learned all about the linear regression model, which took the form:\n\\[\n\\begin{align}\\\\\n& \\text{for observation }i \\\\\n& \\color{red}{Y_i}\\color{black} = \\color{blue}{\\beta_0 \\cdot{} 1 + \\beta_1 \\cdot{} X_{1i} \\ + \\ ... \\ + \\ \\beta_p \\cdot{} X_{pi}}\\color{black} + \\varepsilon_i \\\\\n\\end{align}\n\\]\nAnd if we wanted to write this more simply, we can express \\(X_1\\) to \\(X_p\\) as an \\(n \\times p\\) matrix (samplesize \\(\\times\\) parameters), and \\(\\beta_0\\) to \\(\\beta_p\\) as a vector of coefficients:\n\\[\n\\begin{align}\n& \\color{red}{\\mathbf{y}}\\color{black} = \\color{blue}{\\boldsymbol{X\\beta}}\\color{black} + \\boldsymbol{\\varepsilon} \\\\\n& \\quad \\\\\n& \\text{where} \\\\\n& \\varepsilon \\sim N(0, \\sigma) \\text{ independently} \\\\\n\\end{align}\n\\] In R, we fitted these models using:\n\nlm(y ~ x1 + x2 + .... xp, data = mydata)  \n\n\n\nQuestion 1\n\n\nRead in the Local Authority data from https://uoepsy.github.io/data/LAAwellbeing.csv and plot the bivariate relationship between wellbeing and time spent outdoors.\nUsing lm(), fit the simple linear model:\n\\[\n\\text{Wellbeing}_i = \\beta_0 + \\beta_1 \\cdot \\text{Hours per week spent outdoors}_i + \\varepsilon_i\n\\]\nThink about the assumptions we make about this model:\n\\[\n\\text{where} \\quad \\varepsilon_i \\sim N(0, \\sigma) \\text{ independently}\n\\] Have we satisfied this assumption (specifically, the assumption of independence of errors)?\n\n\n\n\n Solution \n\n\n\nscotmw &lt;- read_csv(\"https://uoepsy.github.io/data/LAAwellbeing.csv\") \n\nggplot(data = scotmw, aes(x = outdoor_time, y = wellbeing))+\n  geom_point()+\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\n\nsimplemod &lt;- lm(wellbeing ~ outdoor_time, data = scotmw)\nsummary(simplemod)\n\n\nCall:\nlm(formula = wellbeing ~ outdoor_time, data = scotmw)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-27.4395  -7.5658  -0.3175   6.0831  26.7208 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   39.2723     2.6674  14.723   &lt;2e-16 ***\noutdoor_time   0.1603     0.1462   1.096    0.275    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 11.43 on 130 degrees of freedom\nMultiple R-squared:  0.009155,  Adjusted R-squared:  0.001534 \nF-statistic: 1.201 on 1 and 130 DF,  p-value: 0.2751\n\n\nOur model from the previous question will assume that the residuals for all participants are independent of one another. But is this a reasonable assumption that we can make? Might we not think that the residents of the highlands might have generally higher levels of wellbeing than those living in Glasgow? Additionally, the association between outdoor time and wellbeing might be different depending on where you live?\nThe natural grouping of the people into their respective geographic area introduces a level of dependence which we would be best to account for.\n\n\n\n\nQuestion 2\n\n\nTry running the code below.\n\nggplot(data = scotmw, aes(x = outdoor_time, y = wellbeing))+\n  geom_point()+\n  geom_smooth(method=\"lm\",se=FALSE)\n\nThen try editing the code to include an aesthetic mapping from the LAA to the color in the plot.\nHow do your thoughts about the relationship between outdoor time and wellbeing change?\n\n\n\n\n Solution \n\n\n\nggplot(data = scotmw, aes(x = outdoor_time, y = wellbeing))+\n  geom_point()+\n  geom_smooth(method=\"lm\",se=FALSE)\n\n\n\n\n\n\n\n\n\nggplot(data = scotmw, aes(x = outdoor_time, y = wellbeing, col = laa))+\n  geom_point()+\n  geom_smooth(method=\"lm\",se=FALSE)\n\n\n\n\n\n\n\n\nFrom the second plot, we see a lot of the LAA appear to have a positive relationship (outdoor time is associated with higher wellbeing). There seem to be differences between LAAs in both the general wellbeing level (residents of Na h-Eileanan Siar - the outer hebrides - have high wellbeing), and in how outdoor time is associated with wellbeing (for instance, outdoor time doesn’t seem to help in Glasgow City).\n\n\n\n\nComplete Pooling\nWe can consider the simple regression model (lm(wellbeing ~ outdoor_time, data = scotmw)) to “pool” the information from all observations together. In this ‘Complete Pooling’ approach, we simply ignore the natural clustering of the people into their local authority areas, as if we were unaware of it. The problem is that this assumes the same regression line for all local authority areas, which might not be that appropriate. Additionally, we violate the assumption that our residuals are independent, because all of the residuals from certain groups will be more like one another than they are to the others.\n\n\n\n\n\nComplete pooling can lead to bad fit for certain groups\n\n\n\n\n\n\nNo Pooling\nThere are various ways we could attempt to deal with the problem that our data are in groups (or “clusters”). With the tools you have learned in DAPR2, you may be tempted to try including LAA in the model as another predictor, to allow for some local authority areas being generally better than others:\n\nlm(wellbeing ~ outdoor_time + laa, data = scotmw)\n\nOr even to include an interaction to allow for local authority areas to show different patterns of association between outdoor time and wellbeing:\n\nlm(wellbeing ~ outdoor_time * laa, data = scotmw)\n\nThis approach gets termed the “No Pooling” method, because the information from each cluster contributes only to an estimated parameter for that cluster, and there is no pooling of information across clusters. This is a good start, but it means that a) we are estimating a lot of parameters, and b) we are not necessarily estimating the parameter of interest (the overall effect of practice on reading age). Furthermore, we’ll probably end up having high variance in the estimates at each group.\n\n\nQuestion 3\n\n\nFit a linear model which accounts for the grouping of participants into their different local authorities, but holds the association between outdoor time and wellbeing as constant across LAAs:\n\nmod1 &lt;- lm(wellbeing ~ outdoor_time + laa, data = scotmw)\n\nCan you construct a plot of the fitted values from this model, coloured by LAA?\n\n\n\n\n\n\nHint\n\n\n\n\n\nHint: you might want to use the augment() function from the broom package\n\n\n\n\n\n\n\n Solution \n\n\n\nlibrary(broom)\naugment(mod1) %&gt;%\n  ggplot(.,aes(x=outdoor_time, y=.fitted, col=laa))+\n  geom_line()\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 4\n\n\nWhat happens (to the plot, and to your parameter estimates) when you include the interaction between laa and outdoor_time?\n\n\n\n\n Solution \n\n\n\nmod2 &lt;- lm(wellbeing ~ outdoor_time * laa, data = scotmw)\n\nbroom::augment(mod2) %&gt;%\n  ggplot(.,aes(x=outdoor_time, y=.fitted, col=laa))+\n  geom_line()\n\n\n\n\n\n\n\n\nWe can see now that our model is fitting a different relationship between wellbeing and outdoor time for each LAA. This is good - we’re going to get better estimates for different LAAs (e.g. wellbeing of residents of the Highlands increases with more outdoor time, and wellbeing of residents of Glasgow does not).\nWe can see that this model provides a better fit - it results in a significant reduction in the residual sums of squares:\n\nanova(mod1, mod2)\n\nAnalysis of Variance Table\n\nModel 1: wellbeing ~ outdoor_time + laa\nModel 2: wellbeing ~ outdoor_time * laa\n  Res.Df    RSS Df Sum of Sq   F   Pr(&gt;F)   \n1    111 2826.9                             \n2     92 1864.4 19    962.57 2.5 0.001975 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nBut accounting for this heterogeneity over clusters in the effect of interest comes at the expense of not pooling information across groups to get one estimate for “the association between outdoor time and wellbeing”. Additionally, these models will tend to have low statistical power because they are using fewer observations (only those within each cluster) to estimate parameters which only represent within-cluster effects.\n\n\n\n\n\nAdvanced Data Wrangling\nWith more complex data structures comes more in-depth data wrangling in order to get it ready for fitting and estimating our model. Typically, the data we get will not be neat and tidy, and will come in different formats. Often we simply get whatever our experiment/questionnaire software spits out, and we have to work from there. When you are designing a study, you can do work on the front end to minimise the data-wrangling. Try to design an experiment/questionnaire while keeping in mind what the data comes out looking like.\nBelow we have some data from a fake experiment. We’ve tried to make it a bit more difficult to work with - a bit more similar to what we would actually get when doing real-life research.\n\nData: Audio interference in executive functioning\nThis data is from a simulated study that aims to investigate the following research question:\n\nHow do different types of audio interfere with executive functioning, and does this interference differ depending upon whether or not noise-cancelling headphones are used?\n\n24 healthy volunteers each completed the Symbol Digit Modalities Test (SDMT) - a commonly used test to assess processing speed and motor speed - a total of 15 times. During the tests, participants listened to either no audio (5 tests), white noise (5 tests) or classical music (5 tests). Half the participants listened via active-noise-cancelling headphones, and the other half listened via speakers in the room.\nThe data is in stored in two separate files - the research administering the tests recorded the SDMT score in one spreadsheet, while details of the audio used in the experiment are held in a separate sheet\n\nInformation about the audio condition for each trial of each participant is stored in .csv format at https://uoepsy.github.io/data/ef_music.csv. The data is in long format (1 row per participant-trial).\n\n\n\n\n\n\n\n\n\n\nvariable\ndescription\n\n\n\n\nPID\nParticipant ID\n\n\ntrial_n\nTrial Number (1-15)\n\n\naudio\nAudio heard during the test (‘no_audio’, ‘white_noise’,‘music’)\n\n\nheadphones\nWhether the participant listened via speakers in the room or via noise cancelling headphones\n\n\n\n\n\n\nInformation on participants’ Symbol Digit Modalities Test (SDMT) for each trial is stored in .xlsx format at https://uoepsy.github.io/data/ef_sdmt.xlsx. The data is in wide format (1 row per participant, 1 column per trial).\n\n\n\n\n\n\nvariable\ndescription\n\n\n\n\nPID\nParticipant ID\n\n\nTrial_01\nSDMT score in trial 1\n\n\nTrial_02\nSDMT score in trial 2\n\n\nTrial_03\nSDMT score in trial 3\n\n\n…\nSDMT score in trial …\n\n\n…\nSDMT score in trial …\n\n\nTrial_15\nSDMT score in trial 15\n\n\n\n\n\n\n\nQuestion 5\n\n\nGet the data into your R session.\nNote: For one of the files, this is a bit different to how we have given you data in previous exercises. You may remember that for a .csv file, you can read directly into R from the link using, read_csv(\"https://uoepsy.......).\nHowever, in reality you are likely to be confronted with data in all sorts of weird formats, such as .xlsx files from MS Excel. Have a look around the internet to try and find any packages/functions/techniques for getting both the datasets in to R.\n\n\n\n\n\n\nHint\n\n\n\n\n\nFor the .xlsx data:\n\nStep 1: download the data to your computer\n\nStep 2: load the readxl package.\n\nStep 3: use the read_xlsx() function to read in the data, pointing it to the relevant place on your computer.\n\n\n\n\n\n\n\n\n Solution \n\n\nReading in the data for each condition is easy, as it’s just the same as we have been doing in DAPR previously:\n\nef_music &lt;- read_csv(\"https://uoepsy.github.io/data/ef_music.csv\")\nhead(ef_music)\n\n\n\n# A tibble: 6 × 4\n  PID    trial_n  audio       headphones\n  &lt;chr&gt;  &lt;chr&gt;    &lt;fct&gt;       &lt;fct&gt;     \n1 PPT_01 Trial_02 no_audio    speakers  \n2 PPT_01 Trial_08 no_audio    speakers  \n3 PPT_01 Trial_11 no_audio    speakers  \n4 PPT_01 Trial_13 no_audio    speakers  \n5 PPT_01 Trial_15 no_audio    speakers  \n6 PPT_01 Trial_01 white_noise speakers  \n\n\nThe other data is a bit more tricky, but we can actually do all these steps from within R.\n\n# Step 1 - Download the data:  \ndownload.file(url = \"https://uoepsy.github.io/data/ef_sdmt.xlsx\", \n              destfile = \"ef_sdmt.xlsx\", mode = \"wb\")\n# Step 2\nlibrary(readxl)\n# Step 3\nef_sdmt &lt;- read_xlsx(\"ef_sdmt.xlsx\")\nhead(ef_sdmt)\n\n\n\n# A tibble: 6 × 16\n  PID    Trial…¹ Trial…² Trial…³ Trial…⁴ Trial…⁵ Trial…⁶ Trial…⁷ Trial…⁸ Trial…⁹\n  &lt;chr&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 PPT_01      38      31      33      13      19      22      24      23      26\n2 PPT_02      47      43      30      38      56      61      58      55      47\n3 PPT_03      29      36      29      34      44      36      35      41      27\n4 PPT_04      23      14       8      36      27      16      26      15      14\n5 PPT_05      22      24      18      19      23      15      32      18      30\n6 PPT_06      29      27      37      39      36      40      28      26      30\n# … with 6 more variables: Trial_10 &lt;dbl&gt;, Trial_11 &lt;dbl&gt;, Trial_12 &lt;dbl&gt;,\n#   Trial_13 &lt;dbl&gt;, Trial_14 &lt;dbl&gt;, Trial_15 &lt;dbl&gt;, and abbreviated variable\n#   names ¹​Trial_01, ²​Trial_02, ³​Trial_03, ⁴​Trial_04, ⁵​Trial_05, ⁶​Trial_06,\n#   ⁷​Trial_07, ⁸​Trial_08, ⁹​Trial_09\n\n\n\n\n\n\nPivot!\nOne of the more confusing things to get to grips with is the idea of reshaping a dataframe.\nFor different reasons, you might sometimes want to have data in wide, or in long format.\n\n\n\n\n\nSource: https://fromthebottomoftheheap.net/2019/10/25/pivoting-tidily/\n\n\n\n\nWhen the data is wide, we can make it long using pivot_longer(). When we make data longer, we’re essentially making lots of columns into 2 longer columns. Above, in the animation, the wide variable x, y and z go into a new longer column called name that specifies which (x/y/z) it came from, and the values get put into the val column.\nThe animation takes a shortcut in the code it displays above, but you could also use pivot_longer(c(x,y,z), names_to = \"name\", values_to = \"val\"). To reverse this, and put it back to being wide, we tell R which columns to take the names and values from: pivot_wider(names_from = name, values_from = val).\n\n\nQuestion 6\n\n\nIs each dataset in wide or long format? We want them both in long format, so try to reshape either/both if necessary.\n\n\n\n\n\n\nHint\n\n\n\n\n\nHint: in the tidyverse functions, you can specify all columns between column x and column z by using the colon, x:z.\n\n\n\n\n\n\n\n Solution \n\n\nOnly the SDMT data is in wide format:\n\nhead(ef_sdmt)\n\n# A tibble: 6 × 16\n  PID    Trial…¹ Trial…² Trial…³ Trial…⁴ Trial…⁵ Trial…⁶ Trial…⁷ Trial…⁸ Trial…⁹\n  &lt;chr&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 PPT_01      38      31      33      13      19      22      24      23      26\n2 PPT_02      47      43      30      38      56      61      58      55      47\n3 PPT_03      29      36      29      34      44      36      35      41      27\n4 PPT_04      23      14       8      36      27      16      26      15      14\n5 PPT_05      22      24      18      19      23      15      32      18      30\n6 PPT_06      29      27      37      39      36      40      28      26      30\n# … with 6 more variables: Trial_10 &lt;dbl&gt;, Trial_11 &lt;dbl&gt;, Trial_12 &lt;dbl&gt;,\n#   Trial_13 &lt;dbl&gt;, Trial_14 &lt;dbl&gt;, Trial_15 &lt;dbl&gt;, and abbreviated variable\n#   names ¹​Trial_01, ²​Trial_02, ³​Trial_03, ⁴​Trial_04, ⁵​Trial_05, ⁶​Trial_06,\n#   ⁷​Trial_07, ⁸​Trial_08, ⁹​Trial_09\n\n\n\nef_sdmt_long &lt;-\n  ef_sdmt %&gt;%\n  pivot_longer(Trial_01:Trial_15, names_to = \"trial_n\", values_to = \"SDMT\")\n\nhead(ef_sdmt_long)\n\n# A tibble: 6 × 3\n  PID    trial_n   SDMT\n  &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;\n1 PPT_01 Trial_01    38\n2 PPT_01 Trial_02    31\n3 PPT_01 Trial_03    33\n4 PPT_01 Trial_04    13\n5 PPT_01 Trial_05    19\n6 PPT_01 Trial_06    22\n\n\n\n\n\n\nJoining data\nThere are lots of different ways to join data-sets, depending on whether we want to keep rows from one data-set or the other, or keep only those in both data-sets etc.\n\n\n\n\n\nCheck out the help documentation for them all using ?full_join.\n\n\n\n\n\n\nQuestion 7\n\n\nNow comes a fun bit.\nWe have two datasets for this study. We’re interested in how the type of audio (information on this is contained in ef_music.csv) interferes with scores on an executive functioning task (scores are held in the ef_sdmt.xlsx).\nWe’re going to need to join these together!\nWe can just stick them side by side, because they’re in different orders:\n\n\n\nhead(ef_music)\n\n# A tibble: 6 × 4\n  PID    trial_n  audio       headphones\n  &lt;chr&gt;  &lt;chr&gt;    &lt;fct&gt;       &lt;fct&gt;     \n1 PPT_01 Trial_02 no_audio    speakers  \n2 PPT_01 Trial_08 no_audio    speakers  \n3 PPT_01 Trial_11 no_audio    speakers  \n4 PPT_01 Trial_13 no_audio    speakers  \n5 PPT_01 Trial_15 no_audio    speakers  \n6 PPT_01 Trial_01 white_noise speakers  \n\n\n\n\n\n\nhead(ef_sdmt_long)\n\n# A tibble: 6 × 3\n  PID    trial_n   SDMT\n  &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;\n1 PPT_01 Trial_01    38\n2 PPT_01 Trial_02    31\n3 PPT_01 Trial_03    33\n4 PPT_01 Trial_04    13\n5 PPT_01 Trial_05    19\n6 PPT_01 Trial_06    22\n\n\n\n\nProvided that both data-sets contain information on participant number and trial number, which uniquely identify each observation, we can join them together by matching on those variables!\n\n\n\n\n\n\nHint\n\n\n\n\n\nWe’re going to want to use one of left/right/semi/anti/full_join(), and give the function both the long formatted datasets.\nWe should end up with 600 rows (40 participants * 15 trials each).\n\n\n\n\n\n\n\n Solution \n\n\n\nefdata &lt;- full_join(ef_music, ef_sdmt_long)\nhead(efdata)\n\n# A tibble: 6 × 5\n  PID    trial_n  audio       headphones  SDMT\n  &lt;chr&gt;  &lt;chr&gt;    &lt;fct&gt;       &lt;fct&gt;      &lt;dbl&gt;\n1 PPT_01 Trial_02 no_audio    speakers      31\n2 PPT_01 Trial_08 no_audio    speakers      23\n3 PPT_01 Trial_11 no_audio    speakers      23\n4 PPT_01 Trial_13 no_audio    speakers      24\n5 PPT_01 Trial_15 no_audio    speakers      34\n6 PPT_01 Trial_01 white_noise speakers      38\n\n\n\n\n\n\n\nClustering & ICC\n\nQuestion 8\n\n\nContinuing with our audio/executive functioning study, consider the following questions:\nWhat are the units of observations?\nWhat are the groups/clusters?\nWhat varies within these clusters?\nWhat varies between these clusters?\n\n\n\n\n Solution \n\n\nWhat are the units of observations? trials\nWhat are the groups/clusters? participants\nWhat varies within these clusters? the type of audio\nWhat varies between these clusters? whether they listen via headphones or speakers\n\n\n\n\nQuestion 9\n\n\nCalculate the ICC, using the ICCbare() function from the ICC package.\n\n\n\n\n\n\nHint\n\n\n\n\n\nRemember, you can look up the help for a function by typing a ? followed by the function name in the console.\n\n\n\n\n\n\n\n Solution \n\n\n\nlibrary(ICC)\nICCbare(x = PID, y = SDMT, data = efdata)\n\n[1] 0.4782452\n\n\n\n\n\nThink back to the lectures, and about what the ICC represents - the ratio of the variance between the groups to the total variance.\nYou can think of the “variance between the groups” as the group means varying around the overall mean (the black dots around the black line), and the total variance as that plus the addition of the variance of the individual observations around each group mean (each set of coloured points around their respective larger black dot):\n\nggplot(efdata, aes(x=PID, y=SDMT))+\n  geom_point(aes(col=PID),alpha=.3)+\n  stat_summary(geom = \"pointrange\")+\n  geom_hline(yintercept = mean(efdata$SDMT,na.rm=T))+\n  theme(axis.text.x = element_text(angle=60,hjust=1))+\n  guides(col='none')\n\n\n\n\n\n\n\n\nYou can also think of the ICC as the correlation between two randomly drawn observations from the same group. This is a bit of a tricky thing to get your head round if you try to relate it to the type of “correlation” that you are familiar with. Pearson’s correlation (e.g think about a typical scatterplot) operates on pairs of observations (a set of values on the x-axis and their corresponding values on the y-axis), whereas ICC operates on data which is structured in groups.\n\n\n\n\n\n\nOptional: ICC as the expected correlation between two observations from same group\n\n\n\n\n\nLet’s suppose we had only 2 observations in each group.\n\n\n  cluster observation   y\n1 group_1           1   4\n2 group_1           2   2\n3 group_2           1   4\n4 group_2           2   2\n5 group_3           1   7\n6 group_3           2   5\n7     ...         ... ...\n\n\nThe ICC for this data is 0.18:\nNow suppose we reshape our data so that we have one row per group, and one column for each observation to look like this:\n\n\n# A tibble: 7 × 3\n  cluster obs1  obs2 \n  &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;\n1 group_1 4     2    \n2 group_2 4     2    \n3 group_3 7     5    \n4 group_4 2     7    \n5 group_5 3     8    \n6 group_6 6     7    \n7 ...     ...   ...  \n\n\nCalculating Pearson’s correlation on those two columns yields 0.2, which isn’t quite right. It’s close, but not quite..\n\nThe crucial thing here is that it is completely arbitrary which observations get called “obs1” and which get called “obs2”.\nThe data aren’t paired, but grouped.\n\nEssentially, there are lots of different combinations of “pairs” here. There are the ones we have shown above:\n\n\n# A tibble: 7 × 3\n  cluster obs1  obs2 \n  &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;\n1 group_1 4     2    \n2 group_2 4     2    \n3 group_3 7     5    \n4 group_4 2     7    \n5 group_5 3     8    \n6 group_6 6     7    \n7 ...     ...   ...  \n\n\nBut we might have equally chosen these:\n\n\n# A tibble: 7 × 3\n  cluster obs1  obs2 \n  &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;\n1 group_1 2     4    \n2 group_2 2     4    \n3 group_3 7     5    \n4 group_4 7     2    \n5 group_5 3     8    \n6 group_6 6     7    \n7 ...     ...   ...  \n\n\nor these:\n\n\n# A tibble: 7 × 3\n  cluster obs1  obs2 \n  &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;\n1 group_1 2     4    \n2 group_2 4     2    \n3 group_3 7     5    \n4 group_4 2     7    \n5 group_5 8     3    \n6 group_6 6     7    \n7 ...     ...   ...  \n\n\nIf we take the correlation of all these combinations of pairings, then we get our ICC of 0.18!\nICC = the expected correlation of a randomly drawn pair of observations from the same group.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOptional - Extra difficult. Calculate ICC manually\n\n\n\n\n\nWe have equal group sizes here (there are 2 \\(\\times\\) 12 participants, each with 15 observations), which makes calculating ICC by hand a lot easier, but it’s still a bit tricky.\nLet’s take a look at the formula for ICC\n\\[\n\\begin{align}\nICC \\; (\\rho) = & \\frac{\\sigma^2_{b}}{\\sigma^2_{b} + \\sigma^2_e} \\\\\n\\qquad \\\\\n= & \\frac{\\frac{MS_b - MS_e}{k}}{\\frac{MS_b - MS_e}{k} + MS_e} \\\\\n\\qquad \\\\\n= & \\frac{MS_b - MS_e}{MS_b + (k-1)MS_e} \\\\\n\\qquad \\\\\n\\qquad \\\\\n\\text{Where:} & \\\\\nk = & \\textrm{number of observations in each group} \\\\\n\\qquad \\\\\nMS_b = & \\textrm{Mean Squares between groups} \\\\\n= & \\frac{\\text{Sums Squares between groups}}{df_\\text{groups}}\n= \\frac{\\sum\\limits_{i=1}(\\bar{y}_i - \\bar{y})^2}{\\textrm{n groups}-1}\\\\\n\\qquad \\\\\nMS_e = & \\textrm{Mean Squares within groups} \\\\\n= & \\frac{\\text{Sums Squares within groups}}{df_\\text{within groups}}\n= \\frac{\\sum\\limits_{i=1}\\sum\\limits_{j=1}(y_{ij} - \\bar{y_i})^2}{\\textrm{n obs}-\\textrm{n groups}}\\\\\n\\end{align}\n\\] So we’re going to need to calculate the grand mean of \\(y\\), the group means of \\(y\\), and then the various squared differences between group means and grand mean, and between observations and their respective group means.\nThe code below will give us a new column which is the overall mean of y. This bit is fairly straightforward.\n\nefdata %&gt;% mutate(\n  grand_mean = mean(SDMT)\n)\n\n\nWe have seen a lot of the combination of group_by() %&gt;% summarise(), but we can also combine group_by() with mutate()!\n\nTry the following:\n\nefdata %&gt;% mutate(\n    grand_mean = mean(SDMT)\n  ) %&gt;% \n  group_by(PID) %&gt;%\n  mutate(\n    group_mean = mean(SDMT)\n  )\n\n\nThe grouping gets carried forward.\nUsing group_by() can quite easily land you in trouble if you forget that you have grouped the dataframe.\nLook at the output of class() when we have grouped the data. It still mentions something about the grouping.\n\nefdata &lt;- efdata %&gt;% mutate(\n    grand_mean = mean(SDMT)\n  ) %&gt;% \n  group_by(PID) %&gt;%\n  mutate(\n    group_mean = mean(SDMT)\n  )\n\nclass(efdata)\n\n[1] \"grouped_df\" \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\nTo remove the grouping, we can use ungroup() (we could also just add this to the end of our code sequence above and re-run it):\n\nefdata &lt;- ungroup(efdata)\nclass(efdata)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\nNow we need to create a column which is the squared differences between the observations \\(y_{ij}\\) and the group means \\(\\bar{y_i}\\).\nWe also want a column which is the squared differences between the group means \\(\\bar{y_i}\\) and the overall mean \\(\\bar{y}\\).\n\nefdata &lt;- efdata %&gt;% \n  mutate(\n    within = (SDMT-group_mean)^2,\n    between = (group_mean-grand_mean)^2\n  )\n\nAnd then we want to sum them:\n\nssbetween = sum(efdata$between)\nsswithin = sum(efdata$within)\n\nFinally, we divide them by the degrees of freedom.\n\n# Mean Squares between\nmsb = ssbetween / (24-1)\n# Mean Squares within \nmse = sswithin / (360-24)\n\nAnd calculate the ICC!!!\n\n# ICC\n(msb-mse) /(msb + (14*mse))\n\n[1] 0.4782452\n\n\n\n\n\n\nQuestion 10\n\n\nWe have two variables of interest here:\n\naudio (type of audio listened to in a trial)\nheadphones (whether or not the participant had headphones on)\n\nWe’re going to look at them separately for now (we’ll get on to addressing the research question next week).\nCompare how the estimates and the uncertainty (the standard errors) for the audio coefficients compare between these two models:\n\nmod1 &lt;- lm(SDMT ~ audio, data = efdata)\nmod2 &lt;- lm(SDMT ~ audio + PID, data = efdata)\n\nand look how the headphones coefficients compare between these two:\n\nmod3 &lt;- lm(SDMT ~ headphones, data = efdata)\nmod4 &lt;- lm(SDMT ~ headphones + PID, data = efdata)\n\nWhat do you notice?\n\n\n\n\n\n\nHints\n\n\n\n\n\nRecall our answers to question 8:\nWhat are the units of observations? trials\nWhat are the groups/clusters? participants\nWhat varies within these clusters? the type of audio\nWhat varies between these clusters? whether they listen via headphones or speakers\n\n\n\n\n\n\n\n Solution \n\n\nOur standard errors for the audio coefficients become narrower when we account for participant-level differences (mod2).\nThis makes sense, because mod2 explains some variation in the audio groups as being due to participants - the highest “white noise” point is actually still a decrease in SDMT compared to “no_audio” for that participant. Whereas mod1 doesn’t know that that highest “white noise” point is high because it comes from a specific participant. Put another way, having a separate line for each participant (RH plot below), gives us more confidence in the differences between audio-types.\nBecause we have perfectly balanced data (every participant has the same number of trials in each audio-type) then our estimates here do not actually change at all.\n\n\n\n\n\n\n\n\n\nIn contrast, our estimates for headphones coefficients do change when we include PID in the model. And the standard errors actually get larger. This is because the inclusion of the participant in mod4 accounts for some of the variance in each group, which means that our comparison between “speakers” and “headphones” is actually a comparison between two groups of 12 participants (RH plot below), rather than 2 groups of 180 trials (LH plot below).\n\n\n\n\n\n\n\n\n\nThis sort of perfectly balanced design has traditionally been approached with extensions of ANOVA (“repeated measures ANOVA”, “mixed ANOVA”). These methods can partition out variance due to one level of clustering (e.g. subjects), and can examine factorial designs when one factor is within cluster, and the other is between. You can see an example here if you are interested. However, ANOVA has a lot of constraints - it can’t handle multiple levels of clustering (e.g. children in classes in schools), it will likely require treating variables such as time as a factor, and it’s not great with missing data.\nThe multi-level model (MLM) provides a more flexible framework, and this is what we will begin to look at next week."
  },
  {
    "objectID": "02_intromlm.html",
    "href": "02_intromlm.html",
    "title": "Multilevel Models",
    "section": "",
    "text": "A Note on terminology\nThe methods we’re going to learn about in the first five weeks of this course are known by lots of different names: “multilevel models”; “hierarchical linear models”; “mixed-effect models”; “mixed models”; “nested data models”; “random coefficient models”; “random-effects models”; “random parameter models”… and so on).\nWhat the idea boils down to is that model parameters vary at more than one level. This week, we’re going to explore what that means.\nThroughout this course, we will tend to use the terms “mixed effect model”, “linear mixed model (LMM)” and “multilevel model (MLM)” interchangeably."
  },
  {
    "objectID": "02_intromlm.html#introducing-lme4",
    "href": "02_intromlm.html#introducing-lme4",
    "title": "Multilevel Models",
    "section": "Introducing lme4",
    "text": "Introducing lme4\nWe’re going to use the lme4 package, and specifically the functions lmer() and glmer().\n“(g)lmer” here stands for “(generalised) linear mixed effects regression”.\nYou will have seen some use of these functions in the lectures. The broad syntax is:\n\n\nlmer(formula, REML = logical, data = dataframe)\n\n\nWe write the first bit of our formula just the same as our old friend the normal linear model y ~ 1 + x + x2 + ..., where y is the name of our outcome variable, 1 is the intercept (which we don’t have to explicitly state as it will be included anyway) and x, x2 etc are the names of our explanatory variables.\nWith lme4, we now have the addition of __random effect terms)), specified in parenthesis with the | operator (the vertical line | is often found to the left of the z key on QWERTY keyboards).\nWe use the | operator to separate the parameters (intercept, slope etc.) on the LHS, from the grouping variable(s) on the RHS, by which we would like to model these parameters as varying.\n\nRandom Intercepts\nLet us suppose that we wish to model our intercept not as a fixed constant, but as varying randomly according to some grouping around a fixed center. We can such a model by allowing the intercept to vary by our grouping variable (g below):\n\nlmer(y ~ 1 + x + (1|g), data = df)\n\n\\[\n\\begin{align}\n& \\text{Level 1:} \\\\\n& \\color{red}{Y_{ij}} = \\color{blue}{\\beta_{0i} \\cdot 1 + \\beta_{1} \\cdot X_{ij}} + \\varepsilon_{ij} \\\\\n& \\text{Level 2:} \\\\\n& \\color{blue}{\\beta_{0i}} = \\gamma_{00} + \\color{orange}{\\zeta_{0i}} \\\\\n\\end{align}\n\\]\n\n\nRandom Intercepts and Slopes\nBy extension we can also allow the effect y~x to vary between groups, by including the x on the left hand side of | in the random effects part of the call to lmer().\n\nlmer(y ~ 1 + x + (1 + x |g), data = df)\n\n\\[\n\\begin{align}\n& \\text{Level 1:} \\\\\n& \\color{red}{y_{ij}} = \\color{blue}{\\beta_{0i} \\cdot 1 + \\beta_{1i} \\cdot x_{ij}} + \\varepsilon_{ij} \\\\\n& \\text{Level 2:} \\\\\n& \\color{blue}{\\beta_{0i}} = \\gamma_{00} + \\color{orange}{\\zeta_{0i}} \\\\\n& \\color{blue}{\\beta_{1i}} = \\gamma_{10} + \\color{orange}{\\zeta_{1i}} \\\\\n\\end{align}\n\\]"
  },
  {
    "objectID": "02_intromlm.html#estimation",
    "href": "02_intromlm.html#estimation",
    "title": "Multilevel Models",
    "section": "Estimation",
    "text": "Estimation\n\nMaximum Likelihood (ML)\nRemember back to DAPR2 when we introduced logistic regression, and we briefly discussed Maximum likelihood in an explanation of how models are fitted.\nThe key idea of maximum likelihood estimation (MLE) is that we (well, the computer) iteratively finds the set of estimates for our model which it considers to best reproduce our observed data. Recall our simple linear regression model of how time spent outdoors (hrs per week) is associated with mental wellbeing: \\[\n\\color{red}{Wellbeing_i} = \\color{blue}{\\beta_0 \\cdot{} 1 + \\beta_1 \\cdot{} OutdoorTime_{i}} + \\varepsilon_i\n\\] There are values of \\(\\beta_0\\) and \\(\\beta_1\\) and \\(\\sigma_\\varepsilon\\) which maximise the probability of observing the data that we have. For linear regression, these we obtained these same values a different way, via minimising the sums of squares. And we saw that this is not possible for more complex models (e.g., logistic), which is where we turn to MLE.\n\nTo read about the subtle difference between “likelihood” and “probability”, you can find a short explanation here\n\nIf we are estimating just one single parameter (e.g. a mean), then we can imagine the process of maximum likelihood estimation in a one-dimensional world - simply finding the top of the curve:\n\n\n\n\n\nFigure 1: MLE\n\n\n\n\nHowever, our typical models estimate a whole bunch of parameters. The simple regression model above is already having to estimate \\(\\beta_0\\), \\(\\beta_1\\) and \\(\\sigma_\\varepsilon\\), and our multi-level models have far more! With lots of parameters being estimated and all interacting to influence the likelihood, our nice curved line becomes a complex surface (see Left panel of Figure 2). So what we (our computers) need to do is find the maximum, but avoid local maxima and singularities (see Figure 3).\n\n\n\n\n\nFigure 2: MLE for a more complex model\n\n\n\n\n\n\nRestricted Maximum Likelihood (REML)\nWhen it comes to estimating multilevel models, maximum likelihood will consider the fixed effects as unknown values in its estimation of the variance components (the random effect variances). This leads to biased estimates of the variance components, specifically biasing them toward being too small, especially if \\(n_\\textrm{clusters} - n_\\textrm{level 2 predictors} - 1 &lt; 50\\). Restricted Maximum Likelihood (REML), however, separates the estimation of fixed and random parts of the model, leading to unbiased estimates of the variance components.\n\nlmer() models are by default fitted with REML. This is better for small samples.\n\n\n\n\n\n\n\n\nModel Convergence\nFor large datasets and/or complex models (lots of random-effects terms), it is quite common to get a convergence warning. There are lots of different ways to deal with these (to try to rule out hypotheses about what is causing them).\nFor now, if lmer() gives you convergence errors, you could try changing the optimizer. Bobyqa is a good one: add control = lmerControl(optimizer = \"bobyqa\") when you run your model.\n\nlmer(y ~ 1 + x1 + ... + (1 + .... | g), data = df, \n     control = lmerControl(optimizer = \"bobyqa\"))\n\n\n\n\n\n\n\nWhat is a convergence warning??\n\n\n\n\n\nThere are different techniques for maximum likelihood estimation, which we apply by using different ‘optimisers’. Technical problems to do with model convergence and ‘singular fit’ come into play when the optimiser we are using either can’t find a suitable maximum, or gets stuck in a singularity (think of it like a black hole of likelihood, which signifies that there is not enough variation in our data to construct such a complex model).\n\n\n\n\n\nFigure 3: local/global maxima and singularities"
  },
  {
    "objectID": "02_intromlm.html#wellbeing-across-scotland-cross-sectional",
    "href": "02_intromlm.html#wellbeing-across-scotland-cross-sectional",
    "title": "Multilevel Models",
    "section": "Wellbeing Across Scotland (Cross-Sectional)",
    "text": "Wellbeing Across Scotland (Cross-Sectional)\n\nRecall our dataset from last week, in which we used linear regression to determine how outdoor time (hours per week) is associated with wellbeing in different local authority areas (LAAs) of Scotland. We have data from various LAAs, from Glasgow City, to the Highlands.\n\nscotmw &lt;- read_csv(\"https://uoepsy.github.io/data/LAAwellbeing.csv\")\n\n\n\n\n\n\n\n\n\n\nvariable\ndescription\n\n\n\n\nppt\nParticipant ID\n\n\nname\nParticipant Name\n\n\nlaa\nLocal Authority Area\n\n\noutdoor_time\nSelf report estimated number of hours per week spent outdoors\n\n\nwellbeing\nWarwick-Edinburgh Mental Wellbeing Scale (WEMWBS), a self-report measure of mental health and well-being. The scale is scored by summing responses to each item, with items answered on a 1 to 5 Likert scale. The minimum scale score is 14 and the maximum is 70.\n\n\ndensity\nLAA Population Density (people per square km)\n\n\n\n\n\n\n\n\n\nQuestion 1\n\n\nUsing lmer() from the lme4 package, fit a model predict wellbeing from outdoor_time, with by-LAA random intercepts.\nPass the model to summary() to see the output.\n\n\n\n\n Solution \n\n\n\nlibrary(lme4)\nri_model &lt;- lmer(wellbeing ~ outdoor_time + (1 | laa), data = scotmw)\nsummary(ri_model)\n\nLinear mixed model fit by REML ['lmerMod']\nFormula: wellbeing ~ outdoor_time + (1 | laa)\n   Data: scotmw\n\nREML criterion at convergence: 866.6\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-2.2218 -0.7192  0.1217  0.6395  1.8287 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n laa      (Intercept) 106.23   10.307  \n Residual              25.46    5.046  \nNumber of obs: 132, groups:  laa, 20\n\nFixed effects:\n             Estimate Std. Error t value\n(Intercept)  38.18979    2.64778   14.42\noutdoor_time  0.21349    0.07236    2.95\n\nCorrelation of Fixed Effects:\n            (Intr)\noutdoor_tim -0.463\n\n\n\n\n\n\nQuestion 2\n\n\nSometimes the easiest way to start understanding your model is to visualise it.\nLoad the package broom.mixed. Along with some handy functions tidy() and glance() which give us the information we see in summary(), there is a handy function called augment() which returns us the data in the model plus the fitted values, residuals, hat values, Cook’s D etc..\n\nri_model &lt;- lmer(wellbeing ~ outdoor_time + (1 | laa), data = scotmw)\nlibrary(broom.mixed)\naugment(ri_model)\n\n# A tibble: 132 × 14\n   wellbeing outdoor_t…¹ laa   .fitted .resid  .hat .cooksd .fixed   .mu .offset\n       &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1        37          20 West…    32.4  4.64  0.139 7.91e-2   42.5  32.4       0\n 2        34          23 Falk…    31.7  2.28  0.192 3.00e-2   43.1  31.7       0\n 3        39          29 Falk…    33.0  6.00  0.195 2.13e-1   44.4  33.0       0\n 4        42          21 Scot…    40.1  1.95  0.163 1.74e-2   42.7  40.1       0\n 5        37          10 Dumf…    37.4 -0.407 0.167 7.84e-4   40.3  37.4       0\n 6        42          19 Argy…    43.9 -1.91  0.122 1.12e-2   42.2  43.9       0\n 7        38          13 Pert…    46.1 -8.06  0.139 2.39e-1   41.0  46.1       0\n 8        44          21 East…    44.4 -0.414 0.168 8.17e-4   42.7  44.4       0\n 9        47          16 Inve…    42.7  4.30  0.193 1.07e-1   41.6  42.7       0\n10        35          12 Midl…    33.1  1.94  0.161 1.69e-2   40.8  33.1       0\n# … with 122 more rows, 4 more variables: .sqrtXwt &lt;dbl&gt;, .sqrtrwt &lt;dbl&gt;,\n#   .weights &lt;dbl&gt;, .wtres &lt;dbl&gt;, and abbreviated variable name ¹​outdoor_time\n\n\nAdd to the code below to plot the model fitted values, and color them according to LAA. (you will need to edit ri_model to be whatever name you assigned to your model).\n\naugment(ri_model) %&gt;%\n  ggplot(aes(x = outdoor_time, y = ...... \n\n\n\n\n\n Solution \n\n\n\naugment(ri_model) %&gt;%\n  ggplot(aes(x = outdoor_time, y = .fitted, col = laa)) + \n  geom_line()\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 3\n\n\nWe have just fitted the model: \\[\n\\begin{align}\n& \\text{For person } j \\text{ in LAA } i \\\\\n& \\color{red}{\\textrm{Wellbeing}_{ij}}\\color{black} = \\color{blue}{\\beta_{0i} \\cdot 1 + \\beta_{1} \\cdot \\textrm{Outdoor Time}_{ij}}\\color{black} + \\varepsilon_{ij} \\\\\n& \\color{blue}{\\beta_{0i}}\\color{black} = \\gamma_{00} + \\color{orange}{\\zeta_{0i}} \\\\\n\\end{align}\n\\]\nFor our estimates of \\(\\gamma_{00}\\) (the fixed value around which LAA intercepts vary) and \\(\\beta_1\\) (the fixed estimate of the relationship between wellbeing and outdoor time), we can use fixef().\n\nfixef(ri_model)\n\n (Intercept) outdoor_time \n   38.189795     0.213492 \n\n\nCan you add to the plot in the previous question, a thick black line with the intercept and slope given by fixef()?\n\n\n\n\n\n\nHints\n\n\n\n\n\nHint: geom_abline()\n\n\n\n\n\n\n\n Solution \n\n\n\naugment(ri_model) %&gt;%\n  ggplot(aes(x = outdoor_time, y = .fitted, col = laa)) + \n  geom_line() + \n  geom_abline(intercept = fixef(ri_model)[1], slope = fixef(ri_model)[2], lwd = 2)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 4\n\n\nBy now, you should have a plot which looks more or less like the left-hand figure below (we have added on the raw data - the points).\n\n\n\n\n\n\n\nFigure 4: Model fitted values\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Summary model outputlmer(wellbeing~1 + outdoor_time + (1|laa),data = scotmw)\n\n\n\n\n\n  We’re going to map the parts of the plot in Figure 4 to the summary() output of the model in Figure 5. Match the coloured sections Red, Orange, Yellow and Blue in Figure 5 to the descriptions below of Figure 4 A through D.\n\nwhere the black line cuts the y axis\nthe standard deviation of the distances from all the individual LAA lines to the black line\nthe slope of the black line\nthe standard deviation of the distances from all the individual observations to the line for the LAA to which it belongs.\n\nCan you also match those same coloured sections in Figure 5 to the mathematical terms in the model equation:\n\\[\n\\begin{align}\n& \\text{Level 1:} \\\\\n& \\color{red}{Wellbeing_{ij}}\\color{black} = \\color{blue}{\\beta_{0i} \\cdot 1 + \\beta_{1} \\cdot OutdoorTime_{ij}}\\color{black} + \\varepsilon_{ij} \\\\\n& \\text{Level 2:} \\\\\n& \\color{blue}{\\beta_{0i}}\\color{black} = \\gamma_{00} + \\color{orange}{\\zeta_{0i}} \\\\\n\\quad \\\\\n& \\text{where} \\\\\n& \\color{orange}{\\zeta_0}\\color{black} \\sim N(0, \\sigma_{\\color{orange}{\\zeta_{0}}}\\color{black})  \\text{ independently} \\\\\n& \\varepsilon \\sim N(0, \\sigma_{\\varepsilon}) \\text{ independently} \\\\\n\\end{align}\n\\]\n\n\n\n\n Solution \n\n\n\nYellow = B = \\(\\sigma_{\\color{orange}{\\zeta_{0}}}\\)\nRed = D = \\(\\sigma_{\\varepsilon}\\)\n\nBlue = A = \\(\\gamma_{00}\\)\n\nOrange = C = \\(\\beta_{1}\\)\n\n\n\n\n\nQuestion 5\n\n\nFit a model which allows also (along with the intercept) the effect of outdoor_time to vary by-LAA.\nThen, using augment() again, plot the model fitted values. What do you think you will see?\nDoes it look like this model better represents the individual LAAs? Take a look at, for instance, Glasgow City.\n\n\n\n\n Solution \n\n\n\nrs_model &lt;- lmer(wellbeing ~ 1 + outdoor_time + (1 + outdoor_time | laa), data = scotmw)\n\naugment(rs_model) %&gt;%\n  ggplot(aes(x = outdoor_time, y = .fitted, col = laa)) + \n  geom_line() + \n  geom_point(aes(y=wellbeing), alpha=.4)"
  },
  {
    "objectID": "02_intromlm.html#wellbeing-over-time-longitudinal",
    "href": "02_intromlm.html#wellbeing-over-time-longitudinal",
    "title": "Multilevel Models",
    "section": "Wellbeing Over Time (Longitudinal)",
    "text": "Wellbeing Over Time (Longitudinal)\nAnother very crucial advantage of these methods is that we can use them to study how people change over time.\n\nWellbeing in Work: Longitudinal Data\nThe “Wellbeing in Work” dataset contains information on employees who were randomly assigned to one of three employment conditions:\n\ncontrol: No change to employment. Employees continue at 5 days a week, with standard allocated annual leave quota.\n\nunlimited_leave : Employees were given no limit to their annual leave, but were still expected to meet required targets as specified in their job description.\nfourday_week: Employees worked a 4 day week for no decrease in pay, and were still expected to meet required targets as specified in their job description.\n\nWellbeing was was assessed at baseline (start of maintenance), 12 months post, 24 months post, and 36 months post.\nThe researchers had two main questions:\n\nQ1): Overall, did the participants’ wellbeing stay the same or did it change?\nQ2): Did the employment condition groups differ in the how wellbeing changed over the assessment period?\n\nThe data is available, in .rda format, at https://uoepsy.github.io/data/wellbeingwork3.rda. You can read it directly into your R environment using:\n\nload(url(\"https://uoepsy.github.io/data/wellbeingwork3.rda\"))\n\nAfter running the code above you will find the data in an object called wellbeingwork3 in your environment.\n\n\nQuestion 9\n\n\n\nQ1): Overall, did the participants’ wellbeing stay the same or did it change?\n\nEach of our participants have measurements at 4 assessments. We need to think about what this means for the random effects that we will include in our model (our random effect structure). Would we like our models to accommodate individuals to vary in their overall wellbeing, to vary in how they change in wellbeing over the course of the assessment period, or both?\nTo investigate whether wellbeing changed over the course of the assessments, or whether it stayed the same, we can fit and compare 2 models:\n\nThe “null” or “intercept-only” model.\nA model with wellbeing predicted by time point.\n\nAnd we can then compare them in terms of model fit (as mentioned above, there are lots of different ways we might do this).\nOur sample size here (180 participants, each with 4 observations) is reasonably large given the relative simplicity of our model. We might consider running a straightforward Likelihood Ratio Test using anova(restricted_model, full_model) to compare our two models (in which case we should fit them with REML=FALSE)\n\n\n\n\n\n\nHints\n\n\n\n\n\n\nRemember, we shouldn’t use likelihood ratio tests to compare models with different random effect structures.\n\n(For now, don’t worry too much about “singular fits”. We’ll talk more about how we might deal with them next week!)\n\n\n\n\n\n\n\n\n Solution \n\n\nThis is our null model:\n\nm.null &lt;- lmer(Wellbeing ~ 1 + (1 | ID), data=wellbeingwork3, REML=FALSE)\nsummary(m.null)\n\nLinear mixed model fit by maximum likelihood  ['lmerMod']\nFormula: Wellbeing ~ 1 + (1 | ID)\n   Data: wellbeingwork3\n\n     AIC      BIC   logLik deviance df.resid \n  4400.8   4414.6  -2197.4   4394.8      717 \n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-2.5224 -0.6067 -0.0426  0.5918  3.6020 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n ID       (Intercept)  4.762   2.182   \n Residual             22.479   4.741   \nNumber of obs: 720, groups:  ID, 180\n\nFixed effects:\n            Estimate Std. Error t value\n(Intercept)  40.0431     0.2402   166.7\n\n\nWe can see the 4.76 / (4.76 + 22.48), or 0.17 of the total variance is attributable to participant-level variation.\nNow lets suppose we want to compare this null model with a model with an effect of TimePoint (to assess whether there is overall change over time). Which model should we compare m.null to?\n\nmodA &lt;- lmer(Wellbeing ~ 1 + TimePoint + (1 + TimePoint | ID), data=wellbeingwork3, REML=FALSE)\nmodB &lt;- lmer(Wellbeing ~ 1 + TimePoint + (1 | ID), data=wellbeingwork3, REML=FALSE)\n\nA comparison between these m.null and modA will not be assessing the influence of only the fixed effect of TimePoint (remember, we shouldn’t compare models that differ in both fixed and random effects)\nHowever, modB doesn’t include our by-participant random effects of timepoint, so comparing this to m.null is potentially going to mis-attribute random deviations in participants’ change to being an overall effect of timepoint.\nIf we want to conduct a model comparison to isolate the effect of overall change over time (a fixed effect of TimePoint), we might want to compare these two models:\n\nm.base0 &lt;- lmer(Wellbeing ~ 1 + (1 + TimePoint | ID), data=wellbeingwork3, REML=FALSE)\nm.base &lt;- lmer(Wellbeing ~ 1 + TimePoint + (1 + TimePoint | ID), data=wellbeingwork3, REML=FALSE)\n\nThe first of these models is a bit weird to think about - how can we have by-participant random deviations of TimePoint if we don’t have a fixed effect of TimePoint? That makes very little sense. What it is actually fitting is a model where there is assumed to be no overall effect of TimePoint. So the fixed effect is 0.\n\n# Straightforward LRT\nanova(m.base0, m.base)\n\nData: wellbeingwork3\nModels:\nm.base0: Wellbeing ~ 1 + (1 + TimePoint | ID)\nm.base: Wellbeing ~ 1 + TimePoint + (1 + TimePoint | ID)\n        npar    AIC    BIC  logLik deviance  Chisq Df Pr(&gt;Chisq)    \nm.base0    5 4202.4 4225.2 -2096.2   4192.4                         \nm.base     6 4171.7 4199.2 -2079.8   4159.7 32.649  1  1.104e-08 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n\n\nQuestion 10\n\n\n\nQ: Did the employment condition groups differ in the how wellbeing changed over the assessment period?\n\n\nHint: It helps to break it down. There are two questions here:\n\ndo groups differ overall?\n\ndo groups differ over time?\n\nWe can begin to see that we’re asking two questions about the Condition variable here: “is there an effect of Condition?” and “Is there an interaction between TimePoint and Condition?”.\nTry fitting two more models which incrementally build these levels of complexity, and compare them (perhaps to one another, perhaps to models from the previous question - think about what each comparison is testing!)\n\n\n\n\n\n Solution \n\n\n\nm.int &lt;- lmer(Wellbeing ~ 1 + TimePoint + Condition + (1 + TimePoint | ID), \n              data=wellbeingwork3, REML=FALSE)\nm.full &lt;- lmer(Wellbeing ~ 1+ TimePoint*Condition + (1 + TimePoint | ID), \n               data=wellbeingwork3, REML=FALSE)\n\nWe’re going to compare each model to the previous one to examine the improvement in fit due to inclusion of each parameter. We could do this quickly with\n\nanova(m.base0, m.base, m.int, m.full)\n\nData: wellbeingwork3\nModels:\nm.base0: Wellbeing ~ 1 + (1 + TimePoint | ID)\nm.base: Wellbeing ~ 1 + TimePoint + (1 + TimePoint | ID)\nm.int: Wellbeing ~ 1 + TimePoint + Condition + (1 + TimePoint | ID)\nm.full: Wellbeing ~ 1 + TimePoint * Condition + (1 + TimePoint | ID)\n        npar    AIC    BIC  logLik deviance  Chisq Df Pr(&gt;Chisq)    \nm.base0    5 4202.4 4225.2 -2096.2   4192.4                         \nm.base     6 4171.7 4199.2 -2079.8   4159.7 32.649  1  1.104e-08 ***\nm.int      8 4164.3 4200.9 -2074.2   4148.3 11.393  2   0.003358 ** \nm.full    10 4144.6 4190.4 -2062.3   4124.6 23.711  2  7.098e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\nConditions differed overall in wellbeing change \\(\\chi^2(2)=11.39, p = .003\\)\nConditions differed in change over assessment period \\(\\chi^2(2)=23.71, p &lt; .001\\)\n\n\n\n\n\nQuestion 11\n\n\nVisualise the model estimated change in wellbeing over time for each Condition.\n\n\n\n\n\n\nHints\n\n\n\n\n\nThere are lots of ways you can visualise the model, try a couple:\n\nUsing the effects package, this might help: as.data.frame(effect(\"TimePoint:Condition\", model))\n\nWe can also use sjPlot, as we have seen in DAPR2\n\n\n\n\n\n\n\n\n Solution \n\n\nUsing the effect() function (and then adding the means and SEs from the original data):\n\nef &lt;- as.data.frame(effect(\"TimePoint:Condition\", m.full))\n\nggplot(ef, aes(TimePoint, fit, color=Condition)) + \n  geom_line() +\n  geom_ribbon(aes(ymin=lower,ymax=upper,fill=Condition), alpha=.2)+\n  stat_summary(data=wellbeingwork3, aes(y=Wellbeing), \n               fun.data=mean_se, geom=\"pointrange\", size=1) +\n  theme_bw()\n\n\n\n\n\n\n\n\nAdditionally, sjPlot can give us the model fitted values, but it’s trickier to add on the observed means. We can add the raw data using show.data=TRUE, but that will make it a bit messier\n\nlibrary(sjPlot)\nplot_model(m.full, type=\"int\")\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 12\n\n\nExamine the parameter estimates and interpret them (i.e., what does each parameter represent?\nCan you match them with parts of the plot obtained from plot_model(m.full, type=\"int\")?\n\n\n\n\n\n\nHints\n\n\n\n\n\nWe can get the fixed effects using fixef(model), and we can also use tidy(model) from the broom.mixed package, and similar to lm models in DAPR2, we can pull out the bit of the summary() using summary(model)$coefficients.\n\n\n\n\n\n\n\n Solution \n\n\n\n\n                                   Estimate Std. Error t value\n(Intercept)                          38.352      0.394  97.270\nTimePoint                            -0.023      0.322  -0.072\nConditionunlimited_leave             -0.018      0.558  -0.033\nConditionfourday_week                -0.260      0.558  -0.466\nTimePoint:Conditionunlimited_leave    1.357      0.456   2.976\nTimePoint:Conditionfourday_week       2.282      0.456   5.005\n\n\n\n(Intercept) ==&gt; Wellbeing at baseline in ‘control’ group.\n\nTimePoint ==&gt; Slope of welleing change in ‘control’ group.\n\nConditionunlimited_leave ==&gt; baseline wellbeing difference from ‘unlimited_leave’ group relative to ‘control’ group.\n\nConditionfourday_week ==&gt; baseline wellbeing difference from ‘fourday_week’ group relative to ‘control’ group.\n\nTimePoint:Conditionunlimited_leave ==&gt; slope of wellbeing change in ‘unlimited_leave’ group relative to ‘control’ group.\n\nTimePoint:Conditionfourday_week ==&gt; slope of wellbeing change in ‘fourday_week’ group relative to ‘control’ group.\n\n\nplot_model(m.full, type=\"int\")\n\n\n\n\nFigure 7: Well-being over time, for employees working in different conditions\n\n\n\n\n\n(Intercept) ==&gt; the height of the red line at timepoint 0.\n\nTimePoint ==&gt; slope of the red line (basically flat).\n\nConditionunlimited_leave ==&gt; the difference at timepoint 0 in height of the blue line from height of the red line (basically 0, but blue line starts ever so slightly below the red).\n\nConditionfourday_week ==&gt; the difference at timepoint 0 in height of the green line from height of the red line (also very small, but it is a bit further below the red than the blue is).\n\nTimePoint:Conditionunlimited_leave ==&gt; the difference from slope of red line to slope of blue line. i.e. while the red line goes -0.023 for every 1 across, the blue line goes \\(-0.023+1.357=1.334\\) up for every 1 across.\n\nTimePoint:Conditionfourday_week ==&gt; difference from slope of red line to slope of green line. i.e. while the red line goes -0.023 for every 1 across, the green line goes \\(-0.023+2.282=2.259\\) up for every 1 across.\n\n\nCompared to the control group, wellbeing increased by 1.36 points/year more for employees with unlimited leave, and by 2.28 points/year for employees on the 4 day week."
  },
  {
    "objectID": "02_intromlm.html#audio-interference-in-executive-functioning-rpt-measures",
    "href": "02_intromlm.html#audio-interference-in-executive-functioning-rpt-measures",
    "title": "Multilevel Models",
    "section": "Audio Interference in Executive Functioning (Rpt Measures)",
    "text": "Audio Interference in Executive Functioning (Rpt Measures)\nWhile the wellbeing example considers the groupings or ‘clusters’ of different LAAs, a more relate-able grouping in psychological research is that of several observations belonging to the same individual. One obvious benefit of this is that we can collect many more observations with fewer participants but control for the resulting dependency of observations.\n\nRecall the data from the previous week, from an experiment in which executive functioning was measured (via the SDMT) for people when listening to different types of audio, either via normal speakers or via noise-cancelling headphones.\nThis week, we have data from a replication of that study, in which the researchers managed to recruit 30 participants. Unfortunately, some participants did not complete all the trials, so we have an unbalanced design. The data is available at https://uoepsy.github.io/data/ef_replication.csv.\n\n\n\n\n\n\n\n\n\nvariable\ndescription\n\n\n\n\nPID\nParticipant ID\n\n\ntrial_n\nTrial Number (1-15)\n\n\naudio\nAudio heard during the test ('no_audio', 'white_noise','music')\n\n\nheadphones\nWhether the participant listened via speakers in the room or via noise cancelling headphones\n\n\nSDMT\nSymbol Digit Modalities Test (SDMT) score\n\n\n\n\n\n\n\n\n\nQuestion 6\n\n\nHow many participants are there in the data?\nHow many have complete data (15 trials)?\nWhat is the average number of trials that participants completed? What is the minimum?\nDoes every participant have some data for each type of audio?\n\n\n\n\n\n\nHints\n\n\n\n\n\nThe count() function will likely be useful here.\n\n\n\n\n\n\n\n Solution \n\n\n\nefdata &lt;- read_csv(\"https://uoepsy.github.io/data/ef_replication.csv\")\n\nHere are the counts of trials for each participant. We can see that no participant completed all 15 trials. Everyone completed at least 10, and the median was 12.\n\nefdata %&gt;% \n  count(PID) %&gt;%\n  summary()\n\n     PID                  n     \n Length:30          Min.   :10  \n Class :character   1st Qu.:11  \n Mode  :character   Median :12  \n                    Mean   :12  \n                    3rd Qu.:13  \n                    Max.   :14  \n\n\nWe can add in audio to our counting to see that everyone has data from \\(\\geq 2\\) trials for a given audio type.\n\nefdata %&gt;% \n  count(PID,audio) %&gt;%\n  summary()\n\n     PID                    audio          n    \n Length:90          no_audio   :30   Min.   :2  \n Class :character   white_noise:30   1st Qu.:4  \n Mode  :character   music      :30   Median :4  \n                                     Mean   :4  \n                                     3rd Qu.:5  \n                                     Max.   :5  \n\n\n\n\n\n\nQuestion 7\n\n\nSet the reference levels of the audio and headphones variables to “no audio” and “speakers” respectively.\nFit a multilevel model to address the research question below.\n\nHow do different types of audio interfere with executive functioning, and does this interference differ depending upon whether or not noise-cancelling headphones are used?\n\n\n\n\n\n\n\nthings to think about:\n\n\n\n\n\n\nwhat is our outcome variable of interest?\nwhat are our predictor variables that we are interested in?\n\nthese should be in the fixed effects part.\n\n\nwhat is the clustering?\n\nthis should be the random effects (1 | cluster) part\n\ndoes audio type (audio) vary within clusters, or between?\n\nif so, we might be able to fit a random slope of audio | cluster. if not, then it doesn’t make sense to do so.\n\n\ndoes delivery mode (headphones) vary within clusters, or between? - if so, we might be able to fit a random slope of headphones | cluster. if not, then it doesn’t make sense to do so.\n\nIf you get an error about model convergence, consider changing the optimiser (see above)\n\n\n\n\n\n\n\n Solution \n\n\n\nefdata &lt;- efdata %&gt;%\n  mutate(\n    audio = fct_relevel(factor(audio), \"no_audio\"),\n    headphones = fct_relevel(factor(headphones), \"speakers\")\n  )\n\n\nsdmt_mod &lt;- lmer(SDMT ~ audio * headphones + \n              (1 + audio | PID), data = efdata,\n              REML = TRUE, control = lmerControl(optimizer=\"bobyqa\"))\nsummary(sdmt_mod)\n\nLinear mixed model fit by REML ['lmerMod']\nFormula: SDMT ~ audio * headphones + (1 + audio | PID)\n   Data: efdata\nControl: lmerControl(optimizer = \"bobyqa\")\n\nREML criterion at convergence: 2376.2\n\nScaled residuals: \n     Min       1Q   Median       3Q      Max \n-2.34520 -0.62861  0.05762  0.60807  2.21250 \n\nRandom effects:\n Groups   Name             Variance Std.Dev. Corr       \n PID      (Intercept)      51.17    7.153               \n          audiowhite_noise 15.22    3.901    -0.25      \n          audiomusic       13.69    3.700     0.03 -0.16\n Residual                  31.49    5.612               \nNumber of obs: 360, groups:  PID, 30\n\nFixed effects:\n                                          Estimate Std. Error t value\n(Intercept)                               33.25800    1.98899  16.721\naudiowhite_noise                          -0.03044    1.44501  -0.021\naudiomusic                                -8.01731    1.41148  -5.680\nheadphonesanc_headphones                   6.85313    2.81173   2.437\naudiowhite_noise:headphonesanc_headphones  8.02458    2.04497   3.924\naudiomusic:headphonesanc_headphones       -3.58747    2.00128  -1.793\n\nCorrelation of Fixed Effects:\n            (Intr) adwht_ audmsc hdphn_ adw_:_\naudiowht_ns -0.352                            \naudiomusic  -0.174  0.192                     \nhdphnsnc_hd -0.707  0.249  0.123              \nadwht_ns:h_  0.249 -0.707 -0.136 -0.351       \nadmsc:hdph_  0.123 -0.135 -0.705 -0.173  0.191\n\n\n\n\n\n\nQuestion 8\n\n\nWe now have a model, but we don’t have any p-values, confidence intervals, or inferential criteria on which to draw conclusions.\nPick a method of your choosing and perform a test of/provide an interval for the relevant effect of interest.\nProvide a brief write-up of the results along with a visualisation.\n\n\n\n\n\n\nOptions\n\n\n\n\n\nAs with normal regression, we have two main ways in which we can conduct inference. We can focus on our coefficients, or we can compare models.\nThere are a whole load of different methods available for drawing inferences from multilevel models, which means it can be a bit of a never-ending rabbit hole. For the purposes of this course, we’ll limit ourselves to these two:\n\n\n\n\n\n\n\n\n\ndf approximations\nlikelihood-based\n\n\n\n\nmodel parameters\nlibrary(parameters)model_parameters(model, ci_method=\"kr\")\nconfint(model, type=\"profile\")\n\n\nmodel comparison\nlibrary(pbkrtest)KRmodcomp(model1,model0)\nanova(model0,model)\n\n\n\nfit models with REML=TRUE.good option for small samples\nfit models with REML=FALSE.needs large N at both levels (40+)\n\n\n\n\n\n\n\n\n\n\n Solution \n\n\nIn this case we have \\(n=30\\) participants (our level 2 sample size), and each participant has at most 15 observations (and some have fewer). These numbers are possibly a bit small for standard likelihood based methods. We would be better off using models fitted with REML because they will provide more accurate estimates of the variance components (the (1 + audio | PID) bit), and so better estimates of the standard errors for our fixed effects.\nThe easiest option here is to use the parameters package:\n\nlibrary(parameters)\nmodel_parameters(sdmt_mod, ci_method=\"kr\")\n\n# Fixed Effects\n\nParameter                                         | Coefficient |   SE |          95% CI |     t |    df |      p\n-----------------------------------------------------------------------------------------------------------------\n(Intercept)                                       |       33.26 | 1.99 | [ 29.18, 37.34] | 16.71 | 27.97 | &lt; .001\naudio [white_noise]                               |       -0.03 | 1.45 | [ -3.00,  2.94] | -0.02 | 27.59 | 0.983 \naudio [music]                                     |       -8.02 | 1.41 | [-10.92, -5.12] | -5.67 | 27.42 | &lt; .001\nheadphones [anc_headphones]                       |        6.85 | 2.81 | [  1.09, 12.62] |  2.44 | 27.94 | 0.021 \naudio [white_noise] × headphones [anc_headphones] |        8.02 | 2.05 | [  3.83, 12.22] |  3.92 | 27.73 | &lt; .001\naudio [music] × headphones [anc_headphones]       |       -3.59 | 2.00 | [ -7.69,  0.52] | -1.79 | 27.77 | 0.084 \n\n# Random Effects\n\nParameter                              | Coefficient |   SE |        95% CI\n---------------------------------------------------------------------------\nSD (Intercept: PID)                    |        7.15 | 1.11 | [ 5.28, 9.69]\nSD (audiowhite_noise: PID)             |        3.90 | 1.04 | [ 2.31, 6.58]\nSD (audiomusic: PID)                   |        3.70 | 1.10 | [ 2.07, 6.62]\nCor (Intercept~audiowhite_noise: PID)  |       -0.25 | 0.31 | [-0.72, 0.37]\nCor (Intercept~audiomusic: PID)        |        0.03 | 0.32 | [-0.53, 0.58]\nCor (audiowhite_noise~audiomusic: PID) |       -0.16 | 0.41 | [-0.76, 0.58]\nSD (Residual)                          |        5.61 | 0.24 | [ 5.16, 6.10]\n\n\nAnd if we want to go down the model comparison route, we just need to isolate the relevant part(s) of the model that we are interested in. For instance, to test the interaction:\n\nsdmt_res &lt;- lmer(SDMT ~ audio + headphones + \n              (1 + audio | PID), data = efdata,\n              REML = TRUE, control = lmerControl(optimizer=\"bobyqa\"))\nlibrary(pbkrtest)\nKRmodcomp(largeModel = sdmt_mod, smallModel = sdmt_res)\n\nlarge : SDMT ~ audio * headphones + (1 + audio | PID)\nsmall : SDMT ~ audio + headphones + (1 + audio | PID)\n        stat    ndf    ddf F.scaling   p.value    \nFtest 10.637  2.000 26.756   0.96406 0.0003987 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\nInclusion of the interaction between headphones and audio-type was found to improve model fit (\\(F(2, 26.8^*) = 10.64, p &lt; .001\\)).\nWhen listening via speakers, music (but not white noise) was associated with lower scores on the SDMT (TODO) compared to no audio. Wearing ANC-headphones (but not listening to any audio) was associated with higher SDMT scores (TODO) compared to no headphones. This was also evidenced when listening to white-noise (TODO). The apparent detrimental influence of music was not found to differ depending on whether headphones were worn (TODO). These results are displayed in Figure 6.\n\\(\\textrm{ }^*\\): denominator degrees of freedom approximated using Kenward-Rogers method.\n\nlibrary(sjPlot)\nplot_model(sdmt_mod, type=\"int\")\n\n\n\n\nFigure 6: Interaction between the type (no audio/white noise/music) and the delivery (speakers/ANC headphones) on executive functioning task (SDMT)"
  },
  {
    "objectID": "csstests.html",
    "href": "csstests.html",
    "title": "Tests",
    "section": "",
    "text": "learning obj\n\n\nimportant\n\n\nsticky\n\n\n\n\n\nr tips\n\n\nstatbox\n\n\ninterprtation interprtation interprtation\n\n\nQuestion\n\n\nquestion\nwhat is your name?\nwhat is your favourite colour?\n\n\n\n\n Solution \n\n\nsolution\nhello\n\n2+2\n\n[1] 4\n\n\n\n\n\n\n Optional hello my optional friend\n\n\nit’s nice to see you again\n\n\n\n\n\nthis is not a panel\n\n\nthis is a panel\n\n\nthis is a panel\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default."
  },
  {
    "objectID": "example_00_anova.html",
    "href": "example_00_anova.html",
    "title": "Analysis Example: Rpt & Mixed ANOVA",
    "section": "",
    "text": "This is optional for the DAPR3 course, but may be useful for your dissertations should your field/supervisor prefer the ANOVA framework to that of the linear model.\nThis walks briefly through these models with the ez package. There are many other packages available, and many good tutorials online should you desire extra resources in the future:\n\nhttps://www.datanovia.com/en/lessons/repeated-measures-anova-in-r\nhttps://www.r-bloggers.com/2021/04/repeated-measures-of-anova-in-r-complete-tutorial/\nhttps://stats.idre.ucla.edu/r/seminars/repeated-measures-analysis-with-r/\nhttps://www.datanovia.com/en/lessons/mixed-anova-in-r/\n\n\n\nData: Audio interference in executive functioning\nThis data is from a simulated study that aims to investigate the following research questions:\n\nHow do different types of audio interfere with executive functioning, and does this interference differ depending upon whether or not noise-cancelling headphones are used?\n\n24 healthy volunteers each completed the Symbol Digit Modalities Test (SDMT) - a commonly used test to assess processing speed and motor speed - a total of 15 times. During the tests, participants listened to either no audio (5 tests), white noise (5 tests) or classical music (5 tests). Half the participants listened via active-noise-cancelling headphones, and the other half listened via speakers in the room.\nThe data is in stored in two separate files - the research administering the tests recorded the SDMT score in one spreadsheet, while details of the audio used in the experiment are held in a separate sheet\n\nInformation about the audio condition for each trial of each participant is stored in .csv format at https://uoepsy.github.io/data/ef_music.csv. The data is in long format (1 row per participant-trial).\n\n\n\n\n\n\n\n\n\n\nvariable\ndescription\n\n\n\n\nPID\nParticipant ID\n\n\ntrial_n\nTrial Number (1-15)\n\n\naudio\nAudio heard during the test (‘no_audio’, ‘white_noise’,‘music’)\n\n\nheadphones\nWhether the participant listened via speakers in the room or via noise cancelling headphones\n\n\n\n\n\n\nInformation on participants’ Symbol Digit Modalities Test (SDMT) for each trial is stored in .xlsx format at https://uoepsy.github.io/data/ef_sdmt.xlsx. The data is in wide format (1 row per participant, 1 column per trial).\n\n\n\n\n\n\nvariable\ndescription\n\n\n\n\nPID\nParticipant ID\n\n\nTrial_01\nSDMT score in trial 1\n\n\nTrial_02\nSDMT score in trial 2\n\n\nTrial_03\nSDMT score in trial 3\n\n\n…\nSDMT score in trial …\n\n\n…\nSDMT score in trial …\n\n\nTrial_15\nSDMT score in trial 15\n\n\n\n\n\n\nThe code below will read in both datasets and join them for you:\n\n\nCode\nlibrary(tidyverse)\nlibrary(readxl)\ndownload.file(url = \"https://uoepsy.github.io/data/ef_sdmt.xlsx\",\n              destfile = \"ef_sdmt.xlsx\",\n              mode = \"wb\")\nefdata &lt;- \n  left_join(\n    read_csv(\"https://uoepsy.github.io/data/ef_music.csv\"),\n    read_xlsx(\"ef_sdmt.xlsx\") %&gt;%\n      pivot_longer(Trial_01:Trial_15, names_to = \"trial_n\", values_to = \"SDMT\")\n  )\n\n\n\nOne-Way Repeated Measures ANOVA\nFor a repeated measures ANOVA, we have one independent variable that is within group.\nThis would be appropriate if our research question were the following:\n\nHow do different types of audio interfere with executive functioning?\n\nMapping this to the variables in our dataset, our model is going to be SDMT ~ audio, and we want to account for PID differences. So for now we will ignore the headphones variable.\n\n\nCode\nhead(efdata)\n\n\n# A tibble: 6 × 5\n  PID    trial_n  audio       headphones  SDMT\n  &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;       &lt;chr&gt;      &lt;dbl&gt;\n1 PPT_01 Trial_02 no_audio    speakers      31\n2 PPT_01 Trial_08 no_audio    speakers      23\n3 PPT_01 Trial_11 no_audio    speakers      23\n4 PPT_01 Trial_13 no_audio    speakers      24\n5 PPT_01 Trial_15 no_audio    speakers      34\n6 PPT_01 Trial_01 white_noise speakers      38\n\n\nThe easiest way to conduct a repeated measures ANOVA in R is to use the ez package, which comes with some handy functions to visualise the experimental design.\nWe can see from below that every participant completed 5 trials for each type of audio interference:\n\n\nCode\nlibrary(ez)\nezDesign(data = efdata, x = audio, y = PID)\n\n\n\n\n\n\n\n\n\nThe ezANOVA() function takes a few arguments.\nThe ones you will need for this are:\n\ndata the name of the dataframe\ndv the column name for the dependent variable\nwid the column name for the participant id variable\nwithin the column name(s) for the predictor variable(s) that vary within participants\nbetween the column name(s) for any predictor variable(s) that vary between participants\n\nFit a repeated measures ANOVA to examine the effect of the audio type on SDMT:\n\n\nCode\nezANOVA(data = efdata, dv = SDMT, wid = PID, within = audio)\n\n\n$ANOVA\n  Effect DFn DFd        F            p p&lt;.05       ges\n2  audio   2  46 44.69618 1.647271e-11     * 0.2534633\n\n$`Mauchly's Test for Sphericity`\n  Effect         W          p p&lt;.05\n2  audio 0.8105961 0.09927715      \n\n$`Sphericity Corrections`\n  Effect       GGe      p[GG] p[GG]&lt;.05      HFe        p[HF] p[HF]&lt;.05\n2  audio 0.8407573 5.0677e-10         * 0.899603 1.427119e-10         *\n\n\n\n\nMixed ANOVA\nMixed ANOVA can be used to investigate effects of independent variables that are at two different levels, i.e. some are within clusters and some are between.\n\nDoes the effect of audio interference on executive functioning differ depending upon whether or not noise-cancelling headphones are used?\n\nLook at the two lines below. Can you work out what the plots will look like before you run them?\n\n\nCode\nezDesign(data = efdata, x = headphones, y = PID)\nezDesign(data = efdata, x = headphones, y = audio)\n\n\nParticipants 1-20 are in one condition, and 21-40 are in another.\nThis should look like a two big blocks on the diagonal.\n\n\nCode\nezDesign(data = efdata, x = headphones, y = PID)\n\n\n\n\n\n\n\n\n\nIn each condition, all different types of audio were observed in the same number of trials. This should be a full grid:\n\n\nCode\nezDesign(data = efdata, x = headphones, y = audio)\n\n\n\n\n\n\n\n\n\nFit a mixed ANOVA to examine the interaction between audio and headphone use on SDMT:\n\n\nCode\nezANOVA(data = efdata, dv = SDMT, wid = PID, within = audio, between = headphones)\n\n\n$ANOVA\n            Effect DFn DFd         F            p p&lt;.05        ges\n2       headphones   1  22  9.815545 4.836945e-03     * 0.26784992\n3            audio   2  44 59.615596 2.980503e-13     * 0.32788320\n4 headphones:audio   2  44  8.677316 6.657590e-04     * 0.06629911\n\n$`Mauchly's Test for Sphericity`\n            Effect         W         p p&lt;.05\n3            audio 0.9422531 0.5355001      \n4 headphones:audio 0.9422531 0.5355001      \n\n$`Sphericity Corrections`\n            Effect       GGe        p[GG] p[GG]&lt;.05      HFe        p[HF]\n3            audio 0.9454057 1.196469e-12         * 1.031585 2.980503e-13\n4 headphones:audio 0.9454057 8.648057e-04         * 1.031585 6.657590e-04\n  p[HF]&lt;.05\n3         *\n4         *\n\n\nThe ez package also contains some easy plotting functions for factorial experiments, such as ezPlot(). It takes similar arguments to the ezANOVA() function.\n\nlook up the help documentation for ezPlot().\nlet’s use ezPlot() to make a nice plot\n\n\n\nCode\nezPlot(data = efdata, dv = SDMT, \n       wid = PID, within = audio, between = headphones,\n       x = audio, split = headphones)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe same thing in lmer\n\n\n\n\n\n\n\nCode\nlibrary(lme4)\nlibrary(lmerTest)\nmod &lt;- lmer(SDMT ~ 1 + headphones * audio + (1 + audio | PID), \n            data = efdata)\nanova(mod, type=\"III\")\n\n\nType III Analysis of Variance Table with Satterthwaite's method\n                 Sum Sq Mean Sq NumDF DenDF F value    Pr(&gt;F)    \nheadphones        325.0  325.04     1    22  9.8155  0.004837 ** \naudio            3212.0 1606.01     2    22 48.4976 8.626e-09 ***\nheadphones:audio  490.1  245.06     2    22  7.4001  0.003486 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\nCode\nlibrary(sjPlot)\nplot_model(mod, type=\"eff\", terms=c(\"audio\",\"headphones\"))"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to DAPR3",
    "section": "",
    "text": "Welcome to the Data Analysis for Psychology in R 3 (DAPR3) lab workbook. Using the menu above, you can find lab materials for each week. These include sets of exercises along with walkthrough readings in which we introduce some of the more important R code. It is strongly recommended that students have taken Data Analysis for Psychology in R 1 and 2 (DAPR1 & DAPR2)."
  },
  {
    "objectID": "index.html#solutions",
    "href": "index.html#solutions",
    "title": "Welcome to DAPR3",
    "section": "Solutions",
    "text": "Solutions\nSolutions will be made available immediately below each exercise, in the week after they are set, so make sure to re-visit the labs to check your answers."
  },
  {
    "objectID": "index.html#asking-questions",
    "href": "index.html#asking-questions",
    "title": "Welcome to DAPR3",
    "section": "Asking Questions",
    "text": "Asking Questions\nWe encourage you to use the various support options, details of which can be found on the Course Learn Page."
  },
  {
    "objectID": "index.html#tips-on-googling-statistics-and-r",
    "href": "index.html#tips-on-googling-statistics-and-r",
    "title": "Welcome to DAPR3",
    "section": "Tips on googling statistics and R",
    "text": "Tips on googling statistics and R\nSearching online for help with statistics and R can be both a help and a hindrance. If you have an error message in R, copy the error message into google. The results returned can sometimes just cause more confusion, but sometimes something might jump out at you and help you solve the problem. The same applies with searching the internet for help with statistics - search for “what is a p-value”, and you’ll find many many different articles and forum discussions etc. Some of them you will find too technical, but don’t be scared - the vast majority of people work in statistics will find these too technical too. Some of them you might feel are too simple/not helpful. As a general guide, keep clicking around the search responses, and you may end up finding that someone, somewhere, has provided an explanation at the right level. If you find something during your search which you don’t quite understand, feel free to link it in a post on the discussion forum!"
  },
  {
    "objectID": "index.html#feedback-on-labs",
    "href": "index.html#feedback-on-labs",
    "title": "Welcome to DAPR3",
    "section": "Feedback on labs",
    "text": "Feedback on labs\nIf you wish to make suggestions for improvements to these workbooks, please email ppls.psych.stats@ed.ac.uk making sure to include the course name in the subject."
  },
  {
    "objectID": "02_intromlm.html#model-formula",
    "href": "02_intromlm.html#model-formula",
    "title": "Multilevel Models",
    "section": "Model Formula",
    "text": "Model Formula\nWe write the first bit of our formula just the same as our old friend the normal linear model y ~ 1 + x + x2 + ..., where y is the name of our outcome variable, 1 is the intercept (which we don’t have to explicitly state as it will be included anyway) and x, x2 etc are the names of our explanatory variables.\nWith lme4, we now have the addition of random effect terms, specified in parenthesis with the | operator (the vertical line | is often found to the left of the z key on QWERTY keyboards). We use the | operator to separate the parameters (intercept, slope etc.) on the LHS, from the grouping variable(s) on the RHS, by which we would like to model these parameters as varying.\n\nRandom Intercepts\nLet us suppose that we wish to model our intercept not as a fixed constant, but as varying randomly according to some grouping around a fixed center. We can such a model by allowing the intercept to vary by our grouping variable (g below):\n\nlmer(y ~ 1 + x + (1|g), data = df)\n\n\\[\n\\begin{align}\n& \\text{Level 1:} \\\\\n& \\color{red}{Y_{ij}} = \\color{blue}{\\beta_{0i} \\cdot 1 + \\beta_{1} \\cdot X_{ij}} + \\varepsilon_{ij} \\\\\n& \\text{Level 2:} \\\\\n& \\color{blue}{\\beta_{0i}} = \\gamma_{00} + \\color{orange}{\\zeta_{0i}} \\\\\n\\end{align}\n\\]\n\n\nRandom Intercepts and Slopes\nBy extension we can also allow the effect y~x to vary between groups, by including the x on the left hand side of | in the random effects part of the call to lmer().\n\nlmer(y ~ 1 + x + (1 + x |g), data = df)\n\n\\[\n\\begin{align}\n& \\text{Level 1:} \\\\\n& \\color{red}{y_{ij}} = \\color{blue}{\\beta_{0i} \\cdot 1 + \\beta_{1i} \\cdot x_{ij}} + \\varepsilon_{ij} \\\\\n& \\text{Level 2:} \\\\\n& \\color{blue}{\\beta_{0i}} = \\gamma_{00} + \\color{orange}{\\zeta_{0i}} \\\\\n& \\color{blue}{\\beta_{1i}} = \\gamma_{10} + \\color{orange}{\\zeta_{1i}} \\\\\n\\end{align}\n\\]"
  },
  {
    "objectID": "02_intromlm.html#model-estimation",
    "href": "02_intromlm.html#model-estimation",
    "title": "Multilevel Models",
    "section": "Model Estimation",
    "text": "Model Estimation\n\nMaximum Likelihood (ML)\nRemember back to DAPR2 when we introduced logistic regression, and we briefly discussed Maximum likelihood in an explanation of how models are fitted.\nThe key idea of maximum likelihood estimation (MLE) is that we (well, the computer) iteratively finds the set of estimates for our model which it considers to best reproduce our observed data. Recall our simple linear regression model of how time spent outdoors (hrs per week) is associated with mental wellbeing: \\[\n\\color{red}{Wellbeing_i} = \\color{blue}{\\beta_0 \\cdot{} 1 + \\beta_1 \\cdot{} OutdoorTime_{i}} + \\varepsilon_i\n\\] There are values of \\(\\beta_0\\) and \\(\\beta_1\\) and \\(\\sigma_\\varepsilon\\) which maximise the probability of observing the data that we have. For linear regression, these we obtained these same values a different way, via minimising the sums of squares. And we saw that this is not possible for more complex models (e.g., logistic), which is where we turn to MLE.\n\nTo read about the subtle difference between “likelihood” and “probability”, you can find a short explanation here\n\nIf we are estimating just one single parameter (e.g. a mean), then we can imagine the process of maximum likelihood estimation in a one-dimensional world - simply finding the top of the curve:\n\n\n\n\n\nFigure 1: MLE\n\n\n\n\nHowever, our typical models estimate a whole bunch of parameters. The simple regression model above is already having to estimate \\(\\beta_0\\), \\(\\beta_1\\) and \\(\\sigma_\\varepsilon\\), and our multi-level models have far more! With lots of parameters being estimated and all interacting to influence the likelihood, our nice curved line becomes a complex surface (see Left panel of Figure 2). So what we (our computers) need to do is find the maximum, but avoid local maxima and singularities (see Figure 3).\n\n\n\n\n\nFigure 2: MLE for a more complex model\n\n\n\n\n\n\nRestricted Maximum Likelihood (REML)\nWhen it comes to estimating multilevel models, maximum likelihood will consider the fixed effects as fixed, known values in its estimation of the variance components (the random effect variances). This leads to biased estimates of the variance components, specifically biasing them toward being too small, especially if \\(n_\\textrm{clusters} - n_\\textrm{level 2 predictors} - 1 &lt; 50\\). This leads to the standard errors of the fixed effects being too small, thereby inflating our type 1 error rate (i.e. greater chance of incorrectly rejecting our null hypothesis).\nRestricted Maximum Likelihood (REML) is a method that separates the estimation of fixed and random parts of the model, leading to unbiased estimates of the variance components.\n\nWe can choose whether to fit with ML or REML with the REML argument of lmer():\nlmer(formula, data = data.frame, **REML = TRUE/FALSE**)\nlmer() models are by default fitted with REML. This is better for small samples.\n\n\n\n\n\n\n\n\nModel Convergence\nFor large datasets and/or complex models (lots of random-effects terms), it is quite common to get a convergence warning. There are lots of different ways to deal with these (to try to rule out hypotheses about what is causing them).\nFor now, if lmer() gives you convergence errors, you could try changing the optimizer. Bobyqa is a good one: add control = lmerControl(optimizer = \"bobyqa\") when you run your model.\n\nlmer(y ~ 1 + x1 + ... + (1 + .... | g), data = df, \n     control = lmerControl(optimizer = \"bobyqa\"))\n\n\n\n\n\n\n\nWhat is a convergence warning??\n\n\n\n\n\nThere are different techniques for maximum likelihood estimation, which we apply by using different ‘optimisers’. Technical problems to do with model convergence and ‘singular fit’ come into play when the optimiser we are using either can’t find a suitable maximum, or gets stuck in a singularity (think of it like a black hole of likelihood, which signifies that there is not enough variation in our data to construct such a complex model).\n\n\n\n\n\nFigure 3: local/global maxima and singularities"
  }
]